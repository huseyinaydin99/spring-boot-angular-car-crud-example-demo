{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Subject } from 'rxjs/Subject';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * \\@docs-private\n */\nclass MutationObserverFactory {\n  /**\n   * @param {?} callback\n   * @return {?}\n   */\n  create(callback) {\n    return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nclass CdkObserveContent {\n  /**\n   * @param {?} _mutationObserverFactory\n   * @param {?} _elementRef\n   * @param {?} _ngZone\n   */\n  constructor(_mutationObserverFactory, _elementRef, _ngZone) {\n    this._mutationObserverFactory = _mutationObserverFactory;\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._disabled = false;\n    /**\n     * Event emitted for each change in the element's content.\n     */\n    this.event = new EventEmitter();\n    /**\n     * Used for debouncing the emitted values to the observeContent event.\n     */\n    this._debouncer = new Subject();\n  }\n  /**\n   * Whether observing content is disabled. This option can be used\n   * to disconnect the underlying MutationObserver until it is needed.\n   * @return {?}\n   */\n  get disabled() {\n    return this._disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    if (this.debounce > 0) {\n      this._ngZone.runOutsideAngular(() => {\n        this._debouncer.pipe(debounceTime(this.debounce)).subscribe(mutations => this.event.emit(mutations));\n      });\n    } else {\n      this._debouncer.subscribe(mutations => this.event.emit(mutations));\n    }\n    this._observer = this._ngZone.runOutsideAngular(() => {\n      return this._mutationObserverFactory.create(mutations => {\n        this._debouncer.next(mutations);\n      });\n    });\n    if (!this.disabled) {\n      this._enable();\n    }\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    if (changes['disabled']) {\n      changes['disabled'].currentValue ? this._disable() : this._enable();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._disable();\n    this._debouncer.complete();\n  }\n  /**\n   * @return {?}\n   */\n  _disable() {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _enable() {\n    if (this._observer) {\n      this._observer.observe(this._elementRef.nativeElement, {\n        characterData: true,\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n}\n\n/** @nocollapse */\n\nclass ObserversModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { CdkObserveContent as ObserveContent, MutationObserverFactory, CdkObserveContent, ObserversModule };\n//# sourceMappingURL=observers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}