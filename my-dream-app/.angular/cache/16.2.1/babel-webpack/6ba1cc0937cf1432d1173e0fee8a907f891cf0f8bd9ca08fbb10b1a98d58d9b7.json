{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, EventEmitter, Inject, Input, NgModule, Optional, Output, TemplateRef, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW } from '@angular/cdk/keycodes';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport '@angular/forms';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { Subject } from 'rxjs/Subject';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass CdkStepLabel {\n  /**\n   * @param {?} template\n   */\n  constructor(template) {\n    this.template = template;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Used to generate unique ID for each stepper component.\n */\nlet nextId = 0;\n/**\n * Change event emitted on selection changes.\n */\nclass StepperSelectionEvent {}\nclass CdkStep {\n  /**\n   * @param {?} _stepper\n   */\n  constructor(_stepper) {\n    this._stepper = _stepper;\n    /**\n     * Whether user has seen the expanded step content or not.\n     */\n    this.interacted = false;\n    this._editable = true;\n    this._optional = false;\n    this._customCompleted = null;\n  }\n  /**\n   * Whether the user can return to this step once it has been marked as complted.\n   * @return {?}\n   */\n  get editable() {\n    return this._editable;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set editable(value) {\n    this._editable = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether the completion of step is optional.\n   * @return {?}\n   */\n  get optional() {\n    return this._optional;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set optional(value) {\n    this._optional = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether step is marked as completed.\n   * @return {?}\n   */\n  get completed() {\n    return this._customCompleted == null ? this._defaultCompleted : this._customCompleted;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set completed(value) {\n    this._customCompleted = coerceBooleanProperty(value);\n  }\n  /**\n   * @return {?}\n   */\n  get _defaultCompleted() {\n    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;\n  }\n  /**\n   * Selects this step component.\n   * @return {?}\n   */\n  select() {\n    this._stepper.selected = this;\n  }\n  /**\n   * Resets the step to its initial state. Note that this includes resetting form data.\n   * @return {?}\n   */\n  reset() {\n    this.interacted = false;\n    if (this._customCompleted != null) {\n      this._customCompleted = false;\n    }\n    if (this.stepControl) {\n      this.stepControl.reset();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnChanges() {\n    // Since basically all inputs of the MatStep get proxied through the view down to the\n    // underlying MatStepHeader, we have to make sure that change detection runs correctly.\n    this._stepper._stateChanged();\n  }\n}\n\n/** @nocollapse */\n\nclass CdkStepper {\n  /**\n   * @param {?} _dir\n   * @param {?} _changeDetectorRef\n   */\n  constructor(_dir, _changeDetectorRef) {\n    this._dir = _dir;\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * Emits when the component is destroyed.\n     */\n    this._destroyed = new Subject();\n    this._linear = false;\n    this._selectedIndex = 0;\n    /**\n     * Event emitted when the selected step has changed.\n     */\n    this.selectionChange = new EventEmitter();\n    /**\n     * The index of the step that the focus can be set.\n     */\n    this._focusIndex = 0;\n    this._orientation = 'horizontal';\n    this._groupId = nextId++;\n  }\n  /**\n   * Whether the validity of previous steps should be checked or not.\n   * @return {?}\n   */\n  get linear() {\n    return this._linear;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set linear(value) {\n    this._linear = coerceBooleanProperty(value);\n  }\n  /**\n   * The index of the selected step.\n   * @return {?}\n   */\n  get selectedIndex() {\n    return this._selectedIndex;\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n  set selectedIndex(index) {\n    if (this._steps) {\n      // Ensure that the index can't be out of bounds.\n      if (index < 0 || index > this._steps.length - 1) {\n        throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');\n      }\n      if (this._anyControlsInvalidOrPending(index) || index < this._selectedIndex && !this._steps.toArray()[index].editable) {\n        // remove focus from clicked step header if the step is not able to be selected\n        this._stepHeader.toArray()[index].nativeElement.blur();\n      } else if (this._selectedIndex != index) {\n        this._emitStepperSelectionEvent(index);\n        this._focusIndex = this._selectedIndex;\n      }\n    } else {\n      this._selectedIndex = this._focusIndex = index;\n    }\n  }\n  /**\n   * The step that is selected.\n   * @return {?}\n   */\n  get selected() {\n    return this._steps.toArray()[this.selectedIndex];\n  }\n  /**\n   * @param {?} step\n   * @return {?}\n   */\n  set selected(step) {\n    this.selectedIndex = this._steps.toArray().indexOf(step);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\n   * Selects and focuses the next step in list.\n   * @return {?}\n   */\n  next() {\n    this.selectedIndex = Math.min(this._selectedIndex + 1, this._steps.length - 1);\n  }\n  /**\n   * Selects and focuses the previous step in list.\n   * @return {?}\n   */\n  previous() {\n    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);\n  }\n  /**\n   * Resets the stepper to its initial state. Note that this includes clearing form data.\n   * @return {?}\n   */\n  reset() {\n    this.selectedIndex = 0;\n    this._steps.forEach(step => step.reset());\n    this._stateChanged();\n  }\n  /**\n   * Returns a unique id for each step label element.\n   * @param {?} i\n   * @return {?}\n   */\n  _getStepLabelId(i) {\n    return `cdk-step-label-${this._groupId}-${i}`;\n  }\n  /**\n   * Returns unique id for each step content element.\n   * @param {?} i\n   * @return {?}\n   */\n  _getStepContentId(i) {\n    return `cdk-step-content-${this._groupId}-${i}`;\n  }\n  /**\n   * Marks the component to be change detected.\n   * @return {?}\n   */\n  _stateChanged() {\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Returns position state of the step with the given index.\n   * @param {?} index\n   * @return {?}\n   */\n  _getAnimationDirection(index) {\n    const /** @type {?} */position = index - this._selectedIndex;\n    if (position < 0) {\n      return this._layoutDirection() === 'rtl' ? 'next' : 'previous';\n    } else if (position > 0) {\n      return this._layoutDirection() === 'rtl' ? 'previous' : 'next';\n    }\n    return 'current';\n  }\n  /**\n   * Returns the type of icon to be displayed.\n   * @param {?} index\n   * @return {?}\n   */\n  _getIndicatorType(index) {\n    const /** @type {?} */step = this._steps.toArray()[index];\n    if (!step.completed || this._selectedIndex == index) {\n      return 'number';\n    } else {\n      return step.editable ? 'edit' : 'done';\n    }\n  }\n  /**\n   * @param {?} newIndex\n   * @return {?}\n   */\n  _emitStepperSelectionEvent(newIndex) {\n    const /** @type {?} */stepsArray = this._steps.toArray();\n    this.selectionChange.emit({\n      selectedIndex: newIndex,\n      previouslySelectedIndex: this._selectedIndex,\n      selectedStep: stepsArray[newIndex],\n      previouslySelectedStep: stepsArray[this._selectedIndex]\n    });\n    this._selectedIndex = newIndex;\n    this._stateChanged();\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onKeydown(event) {\n    const /** @type {?} */keyCode = event.keyCode;\n    // Note that the left/right arrows work both in vertical and horizontal mode.\n    if (keyCode === RIGHT_ARROW) {\n      this._layoutDirection() === 'rtl' ? this._focusPreviousStep() : this._focusNextStep();\n      event.preventDefault();\n    }\n    if (keyCode === LEFT_ARROW) {\n      this._layoutDirection() === 'rtl' ? this._focusNextStep() : this._focusPreviousStep();\n      event.preventDefault();\n    }\n    // Note that the up/down arrows only work in vertical mode.\n    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#tabpanel\n    if (this._orientation === 'vertical' && (keyCode === UP_ARROW || keyCode === DOWN_ARROW)) {\n      keyCode === UP_ARROW ? this._focusPreviousStep() : this._focusNextStep();\n      event.preventDefault();\n    }\n    if (keyCode === SPACE || keyCode === ENTER) {\n      this.selectedIndex = this._focusIndex;\n      event.preventDefault();\n    }\n    if (keyCode === HOME) {\n      this._focusStep(0);\n      event.preventDefault();\n    }\n    if (keyCode === END) {\n      this._focusStep(this._steps.length - 1);\n      event.preventDefault();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _focusNextStep() {\n    this._focusStep((this._focusIndex + 1) % this._steps.length);\n  }\n  /**\n   * @return {?}\n   */\n  _focusPreviousStep() {\n    this._focusStep((this._focusIndex + this._steps.length - 1) % this._steps.length);\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n  _focusStep(index) {\n    this._focusIndex = index;\n    this._stepHeader.toArray()[this._focusIndex].nativeElement.focus();\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n  _anyControlsInvalidOrPending(index) {\n    const /** @type {?} */steps = this._steps.toArray();\n    steps[this._selectedIndex].interacted = true;\n    if (this._linear && index >= 0) {\n      return steps.slice(0, index).some(step => {\n        const /** @type {?} */control = step.stepControl;\n        const /** @type {?} */isIncomplete = control ? control.invalid || control.pending || !step.interacted : !step.completed;\n        return isIncomplete && !step.optional;\n      });\n    }\n    return false;\n  }\n  /**\n   * @return {?}\n   */\n  _layoutDirection() {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Button that moves to the next step in a stepper workflow.\n */\nclass CdkStepperNext {\n  /**\n   * @param {?} _stepper\n   */\n  constructor(_stepper) {\n    this._stepper = _stepper;\n    /**\n     * Type of the next button. Defaults to \"submit\" if not specified.\n     */\n    this.type = 'submit';\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Button that moves to the previous step in a stepper workflow.\n */\nclass CdkStepperPrevious {\n  /**\n   * @param {?} _stepper\n   */\n  constructor(_stepper) {\n    this._stepper = _stepper;\n    /**\n     * Type of the previous button. Defaults to \"button\" if not specified.\n     */\n    this.type = 'button';\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass CdkStepperModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { StepperSelectionEvent, CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious, CdkStepperModule };\n//# sourceMappingURL=stepper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}