{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CommonModule } from '@angular/common';\nimport { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Inject, Input, NgModule, Optional, Output, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { MatCommonModule, MatLine, MatLineModule, MatLineSetter, MatPseudoCheckboxModule, MatRippleModule, mixinDisableRipple, mixinDisabled } from '@angular/material/core';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Subscription } from 'rxjs/Subscription';\nimport { MatDividerModule } from '@angular/material/divider';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\nclass MatListBase {}\nconst _MatListMixinBase = mixinDisableRipple(MatListBase);\n/**\n * \\@docs-private\n */\nclass MatListItemBase {}\nconst _MatListItemMixinBase = mixinDisableRipple(MatListItemBase);\nclass MatNavList extends _MatListMixinBase {}\n\n/** @nocollapse */\n\nclass MatList extends _MatListMixinBase {}\n\n/** @nocollapse */\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nclass MatListAvatarCssMatStyler {}\n\n/** @nocollapse */\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nclass MatListIconCssMatStyler {}\n\n/** @nocollapse */\n\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nclass MatListSubheaderCssMatStyler {}\n\n/** @nocollapse */\n\n/**\n * An item within a Material Design list.\n */\nclass MatListItem extends _MatListItemMixinBase {\n  /**\n   * @param {?} _element\n   * @param {?} _navList\n   */\n  constructor(_element, _navList) {\n    super();\n    this._element = _element;\n    this._navList = _navList;\n    this._isNavList = false;\n    this._isNavList = !!_navList;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    // TODO: consider turning the setter into a function, it doesn't do anything as a class.\n    // tslint:disable-next-line:no-unused-expression\n    new MatLineSetter(this._lines, this._element);\n  }\n  /**\n   * Whether this list item should show a ripple effect when clicked.\n   * @return {?}\n   */\n  _isRippleDisabled() {\n    return !this._isNavList || this.disableRipple || this._navList.disableRipple;\n  }\n  /**\n   * @return {?}\n   */\n  _handleFocus() {\n    this._element.nativeElement.classList.add('mat-list-item-focus');\n  }\n  /**\n   * @return {?}\n   */\n  _handleBlur() {\n    this._element.nativeElement.classList.remove('mat-list-item-focus');\n  }\n  /**\n   * Retrieves the DOM element of the component host.\n   * @return {?}\n   */\n  _getHostElement() {\n    return this._element.nativeElement;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatSelectionListBase {}\nconst _MatSelectionListMixinBase = mixinDisableRipple(mixinDisabled(MatSelectionListBase));\n/**\n * \\@docs-private\n */\nclass MatListOptionBase {}\nconst _MatListOptionMixinBase = mixinDisableRipple(MatListOptionBase);\n/**\n * \\@docs-private\n */\nconst MAT_SELECTION_LIST_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatSelectionList),\n  multi: true\n};\n/**\n * Change event object emitted by MatListOption whenever the selected state changes.\n * @deprecated Use the `MatSelectionListChange` event on the selection list instead.\n * \\@deletion-target 6.0.0\n */\nclass MatListOptionChange {\n  /**\n   * @param {?} source\n   * @param {?} selected\n   */\n  constructor(source, selected) {\n    this.source = source;\n    this.selected = selected;\n  }\n}\n/**\n * Change event that is being fired whenever the selected state of an option changes.\n */\nclass MatSelectionListChange {\n  /**\n   * @param {?} source\n   * @param {?} option\n   */\n  constructor(source, option) {\n    this.source = source;\n    this.option = option;\n  }\n}\n/**\n * Component for list-options of selection-list. Each list-option can automatically\n * generate a checkbox and can put current item into the selectionModel of selection-list\n * if the current item is selected.\n */\nclass MatListOption extends _MatListOptionMixinBase {\n  /**\n   * @param {?} _element\n   * @param {?} _changeDetector\n   * @param {?} selectionList\n   */\n  constructor(_element, _changeDetector, /** @docs-private */\n  selectionList) {\n    super();\n    this._element = _element;\n    this._changeDetector = _changeDetector;\n    this.selectionList = selectionList;\n    this._selected = false;\n    this._disabled = false;\n    /**\n     * Whether the option has focus.\n     */\n    this._hasFocus = false;\n    /**\n     * Whether the label should appear before or after the checkbox. Defaults to 'after'\n     */\n    this.checkboxPosition = 'after';\n    /**\n     * Emits a change event whenever the selected state of an option changes.\n     * @deprecated Use the `selectionChange` event on the `<mat-selection-list>` instead.\n     * \\@deletion-target 6.0.0\n     */\n    this.selectionChange = new EventEmitter();\n  }\n  /**\n   * Whether the option is disabled.\n   * @return {?}\n   */\n  get disabled() {\n    return this._disabled || this.selectionList && this.selectionList.disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    const /** @type {?} */newValue = coerceBooleanProperty(value);\n    if (newValue !== this._disabled) {\n      this._disabled = newValue;\n      this._changeDetector.markForCheck();\n    }\n  }\n  /**\n   * Whether the option is selected.\n   * @return {?}\n   */\n  get selected() {\n    return this.selectionList.selectedOptions.isSelected(this);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set selected(value) {\n    const /** @type {?} */isSelected = coerceBooleanProperty(value);\n    if (isSelected !== this._selected) {\n      this._setSelected(isSelected);\n      this.selectionList._reportValueChange();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    // List options that are selected at initialization can't be reported properly to the form\n    // control. This is because it takes some time until the selection-list knows about all\n    // available options. Also it can happen that the ControlValueAccessor has an initial value\n    // that should be used instead. Deferring the value change report to the next tick ensures\n    // that the form control value is not being overwritten.\n    const /** @type {?} */wasSelected = this._selected;\n    Promise.resolve().then(() => {\n      if (this._selected || wasSelected) {\n        this.selected = true;\n        this._changeDetector.markForCheck();\n      }\n    });\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    // TODO: consider turning the setter into a function, it doesn't do anything as a class.\n    // tslint:disable-next-line:no-unused-expression\n    new MatLineSetter(this._lines, this._element);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this.selected) {\n      // We have to delay this until the next tick in order\n      // to avoid changed after checked errors.\n      Promise.resolve().then(() => this.selected = false);\n    }\n    this.selectionList._removeOptionFromList(this);\n  }\n  /**\n   * Toggles the selection state of the option.\n   * @return {?}\n   */\n  toggle() {\n    this.selected = !this.selected;\n  }\n  /**\n   * Allows for programmatic focusing of the option.\n   * @return {?}\n   */\n  focus() {\n    this._element.nativeElement.focus();\n  }\n  /**\n   * Returns the list item's text label. Implemented as a part of the FocusKeyManager.\n   * \\@docs-private\n   * @return {?}\n   */\n  getLabel() {\n    return this._text ? this._text.nativeElement.textContent : '';\n  }\n  /**\n   * Whether this list item should show a ripple effect when clicked.\n   * @return {?}\n   */\n  _isRippleDisabled() {\n    return this.disabled || this.disableRipple || this.selectionList.disableRipple;\n  }\n  /**\n   * @return {?}\n   */\n  _handleClick() {\n    if (!this.disabled) {\n      this.toggle();\n      // Emit a change event if the selected state of the option changed through user interaction.\n      this.selectionList._emitChangeEvent(this);\n      // TODO: the `selectionChange` event on the option is deprecated. Remove that in the future.\n      this._emitDeprecatedChangeEvent();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _handleFocus() {\n    this._hasFocus = true;\n    this.selectionList._setFocusedOption(this);\n  }\n  /**\n   * @return {?}\n   */\n  _handleBlur() {\n    this._hasFocus = false;\n    this.selectionList._onTouched();\n  }\n  /**\n   * Retrieves the DOM element of the component host.\n   * @return {?}\n   */\n  _getHostElement() {\n    return this._element.nativeElement;\n  }\n  /**\n   * Sets the selected state of the option.\n   * @param {?} selected\n   * @return {?}\n   */\n  _setSelected(selected) {\n    if (selected === this._selected) {\n      return;\n    }\n    this._selected = selected;\n    if (selected) {\n      this.selectionList.selectedOptions.select(this);\n    } else {\n      this.selectionList.selectedOptions.deselect(this);\n    }\n    this._changeDetector.markForCheck();\n  }\n  /**\n   * Emits a selectionChange event for this option.\n   * @return {?}\n   */\n  _emitDeprecatedChangeEvent() {\n    // TODO: the `selectionChange` event on the option is deprecated. Remove that in the future.\n    this.selectionChange.emit(new MatListOptionChange(this, this.selected));\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Material Design list component where each item is a selectable option. Behaves as a listbox.\n */\nclass MatSelectionList extends _MatSelectionListMixinBase {\n  /**\n   * @param {?} _element\n   * @param {?} tabIndex\n   */\n  constructor(_element, tabIndex) {\n    super();\n    this._element = _element;\n    /**\n     * Emits a change event whenever the selected state of an option changes.\n     */\n    this.selectionChange = new EventEmitter();\n    /**\n     * Tabindex of the selection list.\n     */\n    this.tabIndex = 0;\n    /**\n     * The currently selected options.\n     */\n    this.selectedOptions = new SelectionModel(true);\n    /**\n     * View to model callback that should be called whenever the selected options change.\n     */\n    this._onChange = _ => {};\n    this._modelChanges = Subscription.EMPTY;\n    /**\n     * View to model callback that should be called if the list or its options lost focus.\n     */\n    this._onTouched = () => {};\n    this.tabIndex = parseInt(tabIndex) || 0;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._keyManager = new FocusKeyManager(this.options).withWrap().withTypeAhead().skipPredicate(() => false);\n    if (this._tempValues) {\n      this._setOptionsFromValues(this._tempValues);\n      this._tempValues = null;\n    }\n    // Sync external changes to the model back to the options.\n    this._modelChanges = /** @type {?} */this.selectedOptions.onChange.subscribe(event => {\n      if (event.added) {\n        for (let /** @type {?} */item of event.added) {\n          item.selected = true;\n        }\n      }\n      if (event.removed) {\n        for (let /** @type {?} */item of event.removed) {\n          item.selected = false;\n        }\n      }\n    });\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._modelChanges.unsubscribe();\n  }\n  /**\n   * Focuses the last active list option.\n   * @return {?}\n   */\n  focus() {\n    this._element.nativeElement.focus();\n  }\n  /**\n   * Selects all of the options.\n   * @return {?}\n   */\n  selectAll() {\n    this.options.forEach(option => option._setSelected(true));\n    this._reportValueChange();\n  }\n  /**\n   * Deselects all of the options.\n   * @return {?}\n   */\n  deselectAll() {\n    this.options.forEach(option => option._setSelected(false));\n    this._reportValueChange();\n  }\n  /**\n   * Sets the focused option of the selection-list.\n   * @param {?} option\n   * @return {?}\n   */\n  _setFocusedOption(option) {\n    this._keyManager.updateActiveItemIndex(this._getOptionIndex(option));\n  }\n  /**\n   * Removes an option from the selection list and updates the active item.\n   * @param {?} option\n   * @return {?}\n   */\n  _removeOptionFromList(option) {\n    if (option._hasFocus) {\n      const /** @type {?} */optionIndex = this._getOptionIndex(option);\n      // Check whether the option is the last item\n      if (optionIndex > 0) {\n        this._keyManager.setPreviousItemActive();\n      } else if (optionIndex === 0 && this.options.length > 1) {\n        this._keyManager.setNextItemActive();\n      }\n    }\n  }\n  /**\n   * Passes relevant key presses to our key manager.\n   * @param {?} event\n   * @return {?}\n   */\n  _keydown(event) {\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        if (!this.disabled) {\n          this._toggleSelectOnFocusedOption();\n          // Always prevent space from scrolling the page since the list has focus\n          event.preventDefault();\n        }\n        break;\n      case HOME:\n      case END:\n        event.keyCode === HOME ? this._keyManager.setFirstItemActive() : this._keyManager.setLastItemActive();\n        event.preventDefault();\n        break;\n      default:\n        this._keyManager.onKeydown(event);\n    }\n  }\n  /**\n   * Reports a value change to the ControlValueAccessor\n   * @return {?}\n   */\n  _reportValueChange() {\n    if (this.options) {\n      this._onChange(this._getSelectedOptionValues());\n    }\n  }\n  /**\n   * Emits a change event if the selected state of an option changed.\n   * @param {?} option\n   * @return {?}\n   */\n  _emitChangeEvent(option) {\n    this.selectionChange.emit(new MatSelectionListChange(this, option));\n  }\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} values\n   * @return {?}\n   */\n  writeValue(values) {\n    if (this.options) {\n      this._setOptionsFromValues(values || []);\n    } else {\n      this._tempValues = values;\n    }\n  }\n  /**\n   * Implemented as a part of ControlValueAccessor.\n   * @param {?} isDisabled\n   * @return {?}\n   */\n  setDisabledState(isDisabled) {\n    if (this.options) {\n      this.options.forEach(option => option.disabled = isDisabled);\n    }\n  }\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this._onChange = fn;\n  }\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this._onTouched = fn;\n  }\n  /**\n   * Returns the option with the specified value.\n   * @param {?} value\n   * @return {?}\n   */\n  _getOptionByValue(value) {\n    return this.options.find(option => option.value === value);\n  }\n  /**\n   * Sets the selected options based on the specified values.\n   * @param {?} values\n   * @return {?}\n   */\n  _setOptionsFromValues(values) {\n    this.options.forEach(option => option._setSelected(false));\n    values.map(value => this._getOptionByValue(value)).filter(Boolean).forEach(option => /** @type {?} */option._setSelected(true));\n  }\n  /**\n   * Returns the values of the selected options.\n   * @return {?}\n   */\n  _getSelectedOptionValues() {\n    return this.options.filter(option => option.selected).map(option => option.value);\n  }\n  /**\n   * Toggles the selected state of the currently focused option.\n   * @return {?}\n   */\n  _toggleSelectOnFocusedOption() {\n    let /** @type {?} */focusedIndex = this._keyManager.activeItemIndex;\n    if (focusedIndex != null && this._isValidIndex(focusedIndex)) {\n      let /** @type {?} */focusedOption = this.options.toArray()[focusedIndex];\n      if (focusedOption) {\n        focusedOption.toggle();\n        // Emit a change event because the focused option changed its state through user\n        // interaction.\n        this._emitChangeEvent(focusedOption);\n        // TODO: the `selectionChange` event on the option is deprecated. Remove that in the future.\n        focusedOption._emitDeprecatedChangeEvent();\n      }\n    }\n  }\n  /**\n   * Utility to ensure all indexes are valid.\n   * @param {?} index The index to be checked.\n   * @return {?} True if the index is valid for our list of options.\n   */\n  _isValidIndex(index) {\n    return index >= 0 && index < this.options.length;\n  }\n  /**\n   * Returns the index of the specified list option.\n   * @param {?} option\n   * @return {?}\n   */\n  _getOptionIndex(option) {\n    return this.options.toArray().indexOf(option);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatListModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatListModule, MatListBase, _MatListMixinBase, MatListItemBase, _MatListItemMixinBase, MatNavList, MatList, MatListAvatarCssMatStyler, MatListIconCssMatStyler, MatListSubheaderCssMatStyler, MatListItem, MatSelectionListBase, _MatSelectionListMixinBase, MatListOptionBase, _MatListOptionMixinBase, MAT_SELECTION_LIST_VALUE_ACCESSOR, MatListOptionChange, MatSelectionListChange, MatListOption, MatSelectionList };\n//# sourceMappingURL=list.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}