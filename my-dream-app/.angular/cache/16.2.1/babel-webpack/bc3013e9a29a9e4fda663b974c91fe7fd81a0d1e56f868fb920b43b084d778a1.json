{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { A11yModule, FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, EventEmitter, Inject, InjectionToken, Input, NgModule, Optional, Output, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { CheckboxRequiredValidator, NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatCommonModule, MatRipple, MatRippleModule, mixinColor, mixinDisableRipple, mixinDisabled, mixinTabIndex } from '@angular/material/core';\nimport { CommonModule } from '@angular/common';\nimport { ObserversModule } from '@angular/cdk/observers';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token that can be used to specify the checkbox click behavior.\n */\nconst MAT_CHECKBOX_CLICK_ACTION = new InjectionToken('mat-checkbox-click-action');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Increasing integer for generating unique ids for checkbox components.\nlet nextUniqueId = 0;\n/**\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * \\@docs-private\n */\nconst MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatCheckbox),\n  multi: true\n};\n/** @enum {number} */\nconst TransitionCheckState = {\n  /** The initial state of the component before any user interaction. */\n  Init: 0,\n  /** The state representing the component when it's becoming checked. */\n  Checked: 1,\n  /** The state representing the component when it's becoming unchecked. */\n  Unchecked: 2,\n  /** The state representing the component when it's becoming indeterminate. */\n  Indeterminate: 3\n};\nTransitionCheckState[TransitionCheckState.Init] = \"Init\";\nTransitionCheckState[TransitionCheckState.Checked] = \"Checked\";\nTransitionCheckState[TransitionCheckState.Unchecked] = \"Unchecked\";\nTransitionCheckState[TransitionCheckState.Indeterminate] = \"Indeterminate\";\n/**\n * Change event object emitted by MatCheckbox.\n */\nclass MatCheckboxChange {}\n/**\n * \\@docs-private\n */\nclass MatCheckboxBase {\n  /**\n   * @param {?} _elementRef\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n}\nconst _MatCheckboxMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatCheckboxBase)), 'accent'));\n/**\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\n * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\n * so there is no need to provide them yourself. However, if you want to omit a label and still\n * have the checkbox be accessible, you may supply an [aria-label] input.\n * See: https://www.google.com/design/spec/components/selection-controls.html\n */\nclass MatCheckbox extends _MatCheckboxMixinBase {\n  /**\n   * @param {?} elementRef\n   * @param {?} _changeDetectorRef\n   * @param {?} _focusMonitor\n   * @param {?} tabIndex\n   * @param {?} _clickAction\n   */\n  constructor(elementRef, _changeDetectorRef, _focusMonitor, tabIndex, _clickAction) {\n    super(elementRef);\n    this._changeDetectorRef = _changeDetectorRef;\n    this._focusMonitor = _focusMonitor;\n    this._clickAction = _clickAction;\n    /**\n     * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\n     * take precedence so this may be omitted.\n     */\n    this.ariaLabel = '';\n    /**\n     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n     */\n    this.ariaLabelledby = null;\n    this._uniqueId = `mat-checkbox-${++nextUniqueId}`;\n    /**\n     * A unique id for the checkbox input. If none is supplied, it will be auto-generated.\n     */\n    this.id = this._uniqueId;\n    /**\n     * Whether the label should appear after or before the checkbox. Defaults to 'after'\n     */\n    this.labelPosition = 'after';\n    /**\n     * Name value will be applied to the input element if present\n     */\n    this.name = null;\n    /**\n     * Event emitted when the checkbox's `checked` value changes.\n     */\n    this.change = new EventEmitter();\n    /**\n     * Event emitted when the checkbox's `indeterminate` value changes.\n     */\n    this.indeterminateChange = new EventEmitter();\n    /**\n     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n     * \\@docs-private\n     */\n    this._onTouched = () => {};\n    this._currentAnimationClass = '';\n    this._currentCheckState = TransitionCheckState.Init;\n    this._controlValueAccessorChangeFn = () => {};\n    this._checked = false;\n    this._indeterminate = false;\n    this.tabIndex = parseInt(tabIndex) || 0;\n  }\n  /**\n   * Returns the unique id for the visual hidden input.\n   * @return {?}\n   */\n  get inputId() {\n    return `${this.id || this._uniqueId}-input`;\n  }\n  /**\n   * Whether the checkbox is required.\n   * @return {?}\n   */\n  get required() {\n    return this._required;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether or not the checkbox should appear before or after the label.\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get align() {\n    // align refers to the checkbox relative to the label, while labelPosition refers to the\n    // label relative to the checkbox. As such, they are inverted.\n    return this.labelPosition == 'after' ? 'start' : 'end';\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set align(value) {\n    this.labelPosition = value == 'start' ? 'after' : 'before';\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterViewInit() {\n    this._focusMonitor.monitor(this._inputElement.nativeElement).subscribe(focusOrigin => this._onInputFocusChange(focusOrigin));\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._inputElement.nativeElement);\n  }\n  /**\n   * Whether the checkbox is checked.\n   * @return {?}\n   */\n  get checked() {\n    return this._checked;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set checked(value) {\n    if (value != this.checked) {\n      this._checked = value;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n   * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n   * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n   * set to false.\n   * @return {?}\n   */\n  get indeterminate() {\n    return this._indeterminate;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set indeterminate(value) {\n    const /** @type {?} */changed = value != this._indeterminate;\n    this._indeterminate = value;\n    if (changed) {\n      if (this._indeterminate) {\n        this._transitionCheckState(TransitionCheckState.Indeterminate);\n      } else {\n        this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n      }\n      this.indeterminateChange.emit(this._indeterminate);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n  /**\n   * Method being called whenever the label text changes.\n   * @return {?}\n   */\n  _onLabelTextChange() {\n    // This method is getting called whenever the label of the checkbox changes.\n    // Since the checkbox uses the OnPush strategy we need to notify it about the change\n    // that has been recognized by the cdkObserveContent directive.\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    this.checked = !!value;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this._onTouched = fn;\n  }\n  /**\n   * @param {?} isDisabled\n   * @return {?}\n   */\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * @return {?}\n   */\n  _getAriaChecked() {\n    return this.checked ? 'true' : this.indeterminate ? 'mixed' : 'false';\n  }\n  /**\n   * @param {?} newState\n   * @return {?}\n   */\n  _transitionCheckState(newState) {\n    let /** @type {?} */oldState = this._currentCheckState;\n    let /** @type {?} */element = this._elementRef.nativeElement;\n    if (oldState === newState) {\n      return;\n    }\n    if (this._currentAnimationClass.length > 0) {\n      element.classList.remove(this._currentAnimationClass);\n    }\n    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\n    this._currentCheckState = newState;\n    if (this._currentAnimationClass.length > 0) {\n      element.classList.add(this._currentAnimationClass);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    let /** @type {?} */event = new MatCheckboxChange();\n    event.source = this;\n    event.checked = this.checked;\n    this._controlValueAccessorChangeFn(this.checked);\n    this.change.emit(event);\n  }\n  /**\n   * Function is called whenever the focus changes for the input element.\n   * @param {?} focusOrigin\n   * @return {?}\n   */\n  _onInputFocusChange(focusOrigin) {\n    if (!this._focusRipple && focusOrigin === 'keyboard') {\n      this._focusRipple = this.ripple.launch(0, 0, {\n        persistent: true\n      });\n    } else if (!focusOrigin) {\n      this._removeFocusRipple();\n      this._onTouched();\n    }\n  }\n  /**\n   * Toggles the `checked` state of the checkbox.\n   * @return {?}\n   */\n  toggle() {\n    this.checked = !this.checked;\n  }\n  /**\n   * Event handler for checkbox input element.\n   * Toggles checked state if element is not disabled.\n   * Do not toggle on (change) event since IE doesn't fire change event when\n   *   indeterminate checkbox is clicked.\n   * @param {?} event\n   * @return {?}\n   */\n  _onInputClick(event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `checkbox` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n    // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n    if (!this.disabled && this._clickAction !== 'noop') {\n      // When user manually click on the checkbox, `indeterminate` is set to false.\n      if (this.indeterminate && this._clickAction !== 'check') {\n        Promise.resolve().then(() => {\n          this._indeterminate = false;\n          this.indeterminateChange.emit(this._indeterminate);\n        });\n      }\n      this.toggle();\n      this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n      // Emit our custom change event if the native input emitted one.\n      // It is important to only emit it, if the native input triggered one, because\n      // we don't want to trigger a change event, when the `checked` variable changes for example.\n      this._emitChangeEvent();\n    } else if (!this.disabled && this._clickAction === 'noop') {\n      // Reset native input when clicked with noop. The native checkbox becomes checked after\n      // click, reset it to be align with `checked` value of `mat-checkbox`.\n      this._inputElement.nativeElement.checked = this.checked;\n      this._inputElement.nativeElement.indeterminate = this.indeterminate;\n    }\n  }\n  /**\n   * Focuses the checkbox.\n   * @return {?}\n   */\n  focus() {\n    this._focusMonitor.focusVia(this._inputElement.nativeElement, 'keyboard');\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onInteractionEvent(event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n  }\n  /**\n   * @param {?} oldState\n   * @param {?} newState\n   * @return {?}\n   */\n  _getAnimationClassForCheckStateTransition(oldState, newState) {\n    let /** @type {?} */animSuffix = '';\n    switch (oldState) {\n      case TransitionCheckState.Init:\n        // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n        // [checked] bound to it.\n        if (newState === TransitionCheckState.Checked) {\n          animSuffix = 'unchecked-checked';\n        } else if (newState == TransitionCheckState.Indeterminate) {\n          animSuffix = 'unchecked-indeterminate';\n        } else {\n          return '';\n        }\n        break;\n      case TransitionCheckState.Unchecked:\n        animSuffix = newState === TransitionCheckState.Checked ? 'unchecked-checked' : 'unchecked-indeterminate';\n        break;\n      case TransitionCheckState.Checked:\n        animSuffix = newState === TransitionCheckState.Unchecked ? 'checked-unchecked' : 'checked-indeterminate';\n        break;\n      case TransitionCheckState.Indeterminate:\n        animSuffix = newState === TransitionCheckState.Checked ? 'indeterminate-checked' : 'indeterminate-unchecked';\n        break;\n    }\n    return `mat-checkbox-anim-${animSuffix}`;\n  }\n  /**\n   * Fades out the focus state ripple.\n   * @return {?}\n   */\n  _removeFocusRipple() {\n    if (this._focusRipple) {\n      this._focusRipple.fadeOut();\n      this._focusRipple = null;\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nconst MAT_CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MatCheckboxRequiredValidator),\n  multi: true\n};\n/**\n * Validator for Material checkbox's required attribute in template-driven checkbox.\n * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not\n * work with `mat-checkbox`.\n */\nclass MatCheckboxRequiredValidator extends CheckboxRequiredValidator {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatCheckboxModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, TransitionCheckState, MatCheckboxChange, MatCheckboxBase, _MatCheckboxMixinBase, MatCheckbox, MAT_CHECKBOX_CLICK_ACTION, MatCheckboxModule, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxRequiredValidator };\n//# sourceMappingURL=checkbox.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}