{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { A11yModule, FocusMonitor, FocusTrapFactory } from '@angular/cdk/a11y';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, Inject, InjectionToken, Input, NgModule, NgZone, Optional, Output, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nimport { CdkScrollable, ScrollDispatchModule } from '@angular/cdk/scrolling';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { merge } from 'rxjs/observable/merge';\nimport { filter } from 'rxjs/operators/filter';\nimport { take } from 'rxjs/operators/take';\nimport { startWith } from 'rxjs/operators/startWith';\nimport { takeUntil } from 'rxjs/operators/takeUntil';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { map } from 'rxjs/operators/map';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/Observable';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the Material drawers.\n */\nconst matDrawerAnimations = {\n  /** Animation that slides a drawer in and out. */\n  transformDrawer: trigger('transform', [state('open, open-instant', style({\n    transform: 'translate3d(0, 0, 0)',\n    visibility: 'visible'\n  })), state('void', style({\n    visibility: 'hidden'\n  })), transition('void => open-instant', animate('0ms')), transition('void <=> open, open-instant => void', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @param {?} position\n * @return {?}\n */\nfunction throwMatDuplicatedDrawerError(position) {\n  throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n/**\n * Drawer toggle promise result.\n * @deprecated\n * \\@deletion-target 6.0.0\n */\nclass MatDrawerToggleResult {\n  /**\n   * @param {?} type\n   * @param {?} animationFinished\n   */\n  constructor(type, animationFinished) {\n    this.type = type;\n    this.animationFinished = animationFinished;\n  }\n}\n/**\n * Configures whether drawers should use auto sizing by default.\n */\nconst MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE');\nclass MatDrawerContent {\n  /**\n   * @param {?} _changeDetectorRef\n   * @param {?} _container\n   */\n  constructor(_changeDetectorRef, _container) {\n    this._changeDetectorRef = _changeDetectorRef;\n    this._container = _container;\n    /**\n     * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n     * drawer is open. We use margin rather than transform even for push mode because transform breaks\n     * fixed position elements inside of the transformed element.\n     */\n    this._margins = {\n      left: null,\n      right: null\n    };\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._container._contentMargins.subscribe(margins => {\n      this._margins = margins;\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n}\n\n/** @nocollapse */\n\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nclass MatDrawer {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _focusTrapFactory\n   * @param {?} _focusMonitor\n   * @param {?} _platform\n   * @param {?} _ngZone\n   * @param {?} _doc\n   */\n  constructor(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {\n    this._elementRef = _elementRef;\n    this._focusTrapFactory = _focusTrapFactory;\n    this._focusMonitor = _focusMonitor;\n    this._platform = _platform;\n    this._ngZone = _ngZone;\n    this._doc = _doc;\n    this._elementFocusedBeforeDrawerWasOpened = null;\n    /**\n     * Whether the drawer is initialized. Used for disabling the initial animation.\n     */\n    this._enableAnimations = false;\n    this._position = 'start';\n    this._mode = 'over';\n    this._disableClose = false;\n    /**\n     * Emits whenever the drawer has started animating.\n     */\n    this._animationStarted = new EventEmitter();\n    /**\n     * Current state of the sidenav animation.\n     */\n    this._animationState = 'void';\n    /**\n     * Event emitted when the drawer open state is changed.\n     */\n    this.openedChange =\n    // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n    new EventEmitter( /* isAsync */ /* isAsync */true);\n    /**\n     * Event emitted when the drawer is fully opened.\n     * @deprecated Use `opened` instead.\n     * \\@deletion-target 6.0.0\n     */\n    this.onOpen = this._openedStream;\n    /**\n     * Event emitted when the drawer is fully closed.\n     * @deprecated Use `closed` instead.\n     * \\@deletion-target 6.0.0\n     */\n    this.onClose = this._closedStream;\n    /**\n     * Event emitted when the drawer's position changes.\n     */\n    this.onPositionChanged = new EventEmitter();\n    /**\n     * @deprecated\n     * \\@deletion-target 6.0.0\n     */\n    this.onAlignChanged = new EventEmitter();\n    /**\n     * An observable that emits when the drawer mode changes. This is used by the drawer container to\n     * to know when to when the mode changes so it can adapt the margins on the content.\n     */\n    this._modeChanged = new Subject();\n    this._opened = false;\n    this.openedChange.subscribe(opened => {\n      if (opened) {\n        if (this._doc) {\n          this._elementFocusedBeforeDrawerWasOpened = /** @type {?} */this._doc.activeElement;\n        }\n        if (this._isFocusTrapEnabled && this._focusTrap) {\n          this._trapFocus();\n        }\n      } else {\n        this._restoreFocus();\n      }\n    });\n    /**\n         * Listen to `keydown` events outside the zone so that change detection is not run every\n         * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n         * and we don't have close disabled.\n         */\n    this._ngZone.runOutsideAngular(() => {\n      fromEvent(this._elementRef.nativeElement, 'keydown').pipe(filter(event => event.keyCode === ESCAPE && !this.disableClose)).subscribe(event => this._ngZone.run(() => {\n        this.close();\n        event.stopPropagation();\n      }));\n    });\n  }\n  /**\n   * The side that the drawer is attached to.\n   * @return {?}\n   */\n  get position() {\n    return this._position;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set position(value) {\n    // Make sure we have a valid value.\n    value = value === 'end' ? 'end' : 'start';\n    if (value != this._position) {\n      this._position = value;\n      this.onAlignChanged.emit();\n      this.onPositionChanged.emit();\n    }\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get align() {\n    return this.position;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set align(value) {\n    this.position = value;\n  }\n  /**\n   * Mode of the drawer; one of 'over', 'push' or 'side'.\n   * @return {?}\n   */\n  get mode() {\n    return this._mode;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set mode(value) {\n    this._mode = value;\n    this._modeChanged.next();\n  }\n  /**\n   * Whether the drawer can be closed with the escape key or by clicking on the backdrop.\n   * @return {?}\n   */\n  get disableClose() {\n    return this._disableClose;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disableClose(value) {\n    this._disableClose = coerceBooleanProperty(value);\n  }\n  /**\n   * Event emitted when the drawer has been opened.\n   * @return {?}\n   */\n  get _openedStream() {\n    return this.openedChange.pipe(filter(o => o), map(() => {}));\n  }\n  /**\n   * Event emitted when the drawer has started opening.\n   * @return {?}\n   */\n  get openedStart() {\n    return this._animationStarted.pipe(filter(e => e.fromState !== e.toState && e.toState.indexOf('open') === 0), map(() => {}));\n  }\n  /**\n   * Event emitted when the drawer has been closed.\n   * @return {?}\n   */\n  get _closedStream() {\n    return this.openedChange.pipe(filter(o => !o), map(() => {}));\n  }\n  /**\n   * Event emitted when the drawer has started closing.\n   * @return {?}\n   */\n  get closedStart() {\n    return this._animationStarted.pipe(filter(e => e.fromState !== e.toState && e.toState === 'void'), map(() => {}));\n  }\n  /**\n   * @return {?}\n   */\n  get _isFocusTrapEnabled() {\n    // The focus trap is only enabled when the drawer is open in any mode other than side.\n    return this.opened && this.mode !== 'side';\n  }\n  /**\n   * Traps focus inside the drawer.\n   * @return {?}\n   */\n  _trapFocus() {\n    this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {\n      // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\n      // still works. We need to check that `focus` is a function due to Universal.\n      if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\n        this._elementRef.nativeElement.focus();\n      }\n    });\n  }\n  /**\n   * If focus is currently inside the drawer, restores it to where it was before the drawer\n   * opened.\n   * @return {?}\n   */\n  _restoreFocus() {\n    const /** @type {?} */activeEl = this._doc && this._doc.activeElement;\n    if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\n      if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {\n        this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\n      } else {\n        this._elementRef.nativeElement.blur();\n      }\n    }\n    this._elementFocusedBeforeDrawerWasOpened = null;\n    this._openedVia = null;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n    this._focusTrap.enabled = this._isFocusTrapEnabled;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentChecked() {\n    // Enable the animations after the lifecycle hooks have run, in order to avoid animating\n    // drawers that are open by default. When we're on the server, we shouldn't enable the\n    // animations, because we don't want the drawer to animate the first time the user sees\n    // the page.\n    if (this._platform.isBrowser) {\n      this._enableAnimations = true;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this._focusTrap) {\n      this._focusTrap.destroy();\n    }\n  }\n  /**\n   * Whether the drawer is opened. We overload this because we trigger an event when it\n   * starts or end.\n   * @return {?}\n   */\n  get opened() {\n    return this._opened;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set opened(value) {\n    this.toggle(coerceBooleanProperty(value));\n  }\n  /**\n   * Open the drawer.\n   * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n   * Used for focus management after the sidenav is closed.\n   * @return {?}\n   */\n  open(openedVia) {\n    return this.toggle(true, openedVia);\n  }\n  /**\n   * Close the drawer.\n   * @return {?}\n   */\n  close() {\n    return this.toggle(false);\n  }\n  /**\n   * Toggle this drawer.\n   * @param {?=} isOpen Whether the drawer should be open.\n   * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n   * Used for focus management after the sidenav is closed.\n   * @return {?}\n   */\n  toggle(isOpen = !this.opened, openedVia = 'program') {\n    this._opened = isOpen;\n    if (isOpen) {\n      this._animationState = this._enableAnimations ? 'open' : 'open-instant';\n      this._openedVia = openedVia;\n    } else {\n      this._animationState = 'void';\n      this._restoreFocus();\n    }\n    if (this._focusTrap) {\n      this._focusTrap.enabled = this._isFocusTrapEnabled;\n    }\n    // TODO(crisbeto): This promise is here for backwards-compatibility.\n    // It should be removed next time we do breaking changes in the drawer.\n    // @deletion-target 6.0.0\n    return new Promise(resolve => {\n      this.openedChange.pipe(take(1)).subscribe(open => {\n        resolve(new MatDrawerToggleResult(open ? 'open' : 'close', true));\n      });\n    });\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onAnimationStart(event) {\n    this._animationStarted.emit(event);\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onAnimationEnd(event) {\n    const {\n      fromState,\n      toState\n    } = event;\n    if (toState.indexOf('open') === 0 && fromState === 'void' || toState === 'void' && fromState.indexOf('open') === 0) {\n      this.openedChange.emit(this._opened);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  get _width() {\n    return this._elementRef.nativeElement ? this._elementRef.nativeElement.offsetWidth || 0 : 0;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nclass MatDrawerContainer {\n  /**\n   * @param {?} _dir\n   * @param {?} _element\n   * @param {?} _ngZone\n   * @param {?} _changeDetectorRef\n   * @param {?=} defaultAutosize\n   */\n  constructor(_dir, _element, _ngZone, _changeDetectorRef, defaultAutosize = false) {\n    this._dir = _dir;\n    this._element = _element;\n    this._ngZone = _ngZone;\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * Event emitted when the drawer backdrop is clicked.\n     */\n    this.backdropClick = new EventEmitter();\n    /**\n     * Emits when the component is destroyed.\n     */\n    this._destroyed = new Subject();\n    /**\n     * Emits on every ngDoCheck. Used for debouncing reflows.\n     */\n    this._doCheckSubject = new Subject();\n    this._contentMargins = new Subject();\n    // If a `Dir` directive exists up the tree, listen direction changes\n    // and update the left/right properties to point to the proper start/end.\n    if (_dir) {\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n        this._validateDrawers();\n        this._updateContentMargins();\n      });\n    }\n    this._autosize = defaultAutosize;\n  }\n  /**\n   * The drawer child with the `start` position.\n   * @return {?}\n   */\n  get start() {\n    return this._start;\n  }\n  /**\n   * The drawer child with the `end` position.\n   * @return {?}\n   */\n  get end() {\n    return this._end;\n  }\n  /**\n   * Whether to automatically resize the container whenever\n   * the size of any of its drawers changes.\n   *\n   * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n   * the drawers on every change detection cycle. Can be configured globally via the\n   * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n   * @return {?}\n   */\n  get autosize() {\n    return this._autosize;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set autosize(value) {\n    this._autosize = coerceBooleanProperty(value);\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._drawers.changes.pipe(startWith(null)).subscribe(() => {\n      this._validateDrawers();\n      this._drawers.forEach(drawer => {\n        this._watchDrawerToggle(drawer);\n        this._watchDrawerPosition(drawer);\n        this._watchDrawerMode(drawer);\n      });\n      if (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) {\n        this._updateContentMargins();\n      }\n      this._changeDetectorRef.markForCheck();\n    });\n    this._doCheckSubject.pipe(debounceTime(10),\n    // Arbitrary debounce time, less than a frame at 60fps\n    // Arbitrary debounce time, less than a frame at 60fps\n    takeUntil(this._destroyed)).subscribe(() => this._updateContentMargins());\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._doCheckSubject.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\n   * Calls `open` of both start and end drawers\n   * @return {?}\n   */\n  open() {\n    this._drawers.forEach(drawer => drawer.open());\n  }\n  /**\n   * Calls `close` of both start and end drawers\n   * @return {?}\n   */\n  close() {\n    this._drawers.forEach(drawer => drawer.close());\n  }\n  /**\n   * @return {?}\n   */\n  ngDoCheck() {\n    // If users opted into autosizing, do a check every change detection cycle.\n    if (this._autosize && this._isPushed()) {\n      // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n      this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\n    }\n  }\n  /**\n   * Subscribes to drawer events in order to set a class on the main container element when the\n   * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n   * is properly hidden.\n   * @param {?} drawer\n   * @return {?}\n   */\n  _watchDrawerToggle(drawer) {\n    drawer._animationStarted.pipe(takeUntil(this._drawers.changes), filter(event => event.fromState !== event.toState)).subscribe(event => {\n      // Set the transition class on the container so that the animations occur. This should not\n      // be set initially because animations should only be triggered via a change in state.\n      if (event.toState !== 'open-instant') {\n        this._element.nativeElement.classList.add('mat-drawer-transition');\n      }\n      this._updateContentMargins();\n      this._changeDetectorRef.markForCheck();\n    });\n    if (drawer.mode !== 'side') {\n      drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));\n    }\n  }\n  /**\n   * Subscribes to drawer onPositionChanged event in order to\n   * re-validate drawers when the position changes.\n   * @param {?} drawer\n   * @return {?}\n   */\n  _watchDrawerPosition(drawer) {\n    if (!drawer) {\n      return;\n    }\n    // NOTE: We need to wait for the microtask queue to be empty before validating,\n    // since both drawers may be swapping positions at the same time.\n    drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\n      this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(() => {\n        this._validateDrawers();\n      });\n    });\n  }\n  /**\n   * Subscribes to changes in drawer mode so we can run change detection.\n   * @param {?} drawer\n   * @return {?}\n   */\n  _watchDrawerMode(drawer) {\n    if (drawer) {\n      drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed))).subscribe(() => {\n        this._updateContentMargins();\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n  }\n  /**\n   * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.\n   * @param {?} isAdd\n   * @return {?}\n   */\n  _setContainerClass(isAdd) {\n    if (isAdd) {\n      this._element.nativeElement.classList.add('mat-drawer-opened');\n    } else {\n      this._element.nativeElement.classList.remove('mat-drawer-opened');\n    }\n  }\n  /**\n   * Validate the state of the drawer children components.\n   * @return {?}\n   */\n  _validateDrawers() {\n    this._start = this._end = null;\n    // Ensure that we have at most one start and one end drawer.\n    this._drawers.forEach(drawer => {\n      if (drawer.position == 'end') {\n        if (this._end != null) {\n          throwMatDuplicatedDrawerError('end');\n        }\n        this._end = drawer;\n      } else {\n        if (this._start != null) {\n          throwMatDuplicatedDrawerError('start');\n        }\n        this._start = drawer;\n      }\n    });\n    this._right = this._left = null;\n    // Detect if we're LTR or RTL.\n    if (!this._dir || this._dir.value == 'ltr') {\n      this._left = this._start;\n      this._right = this._end;\n    } else {\n      this._left = this._end;\n      this._right = this._start;\n    }\n  }\n  /**\n   * Whether the container is being pushed to the side by one of the drawers.\n   * @return {?}\n   */\n  _isPushed() {\n    return this._isDrawerOpen(this._start) && /** @type {?} */this._start.mode != 'over' || this._isDrawerOpen(this._end) && /** @type {?} */this._end.mode != 'over';\n  }\n  /**\n   * @return {?}\n   */\n  _onBackdropClicked() {\n    this.backdropClick.emit();\n    this._closeModalDrawer();\n  }\n  /**\n   * @return {?}\n   */\n  _closeModalDrawer() {\n    // Close all open drawers where closing is not disabled and the mode is not `side`.\n    [this._start, this._end].filter(drawer => drawer && !drawer.disableClose && drawer.mode !== 'side').forEach(drawer => /** @type {?} */drawer.close());\n  }\n  /**\n   * @return {?}\n   */\n  _isShowingBackdrop() {\n    return this._isDrawerOpen(this._start) && /** @type {?} */this._start.mode != 'side' || this._isDrawerOpen(this._end) && /** @type {?} */this._end.mode != 'side';\n  }\n  /**\n   * @param {?} drawer\n   * @return {?}\n   */\n  _isDrawerOpen(drawer) {\n    return drawer != null && drawer.opened;\n  }\n  /**\n   * Recalculates and updates the inline styles for the content. Note that this should be used\n   * sparingly, because it causes a reflow.\n   * @return {?}\n   */\n  _updateContentMargins() {\n    // 1. For drawers in `over` mode, they don't affect the content.\n    // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n    //    left margin (for left drawer) or right margin (for right the drawer).\n    // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n    //    adding to the left or right margin and simultaneously subtracting the same amount of\n    //    margin from the other side.\n    let /** @type {?} */left = 0;\n    let /** @type {?} */right = 0;\n    if (this._left && this._left.opened) {\n      if (this._left.mode == 'side') {\n        left += this._left._width;\n      } else if (this._left.mode == 'push') {\n        let /** @type {?} */width = this._left._width;\n        left += width;\n        right -= width;\n      }\n    }\n    if (this._right && this._right.opened) {\n      if (this._right.mode == 'side') {\n        right += this._right._width;\n      } else if (this._right.mode == 'push') {\n        let /** @type {?} */width = this._right._width;\n        right += width;\n        left -= width;\n      }\n    }\n    // Pull back into the NgZone since in some cases we could be outside.\n    this._ngZone.run(() => this._contentMargins.next({\n      left,\n      right\n    }));\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatSidenavContent extends MatDrawerContent {\n  /**\n   * @param {?} changeDetectorRef\n   * @param {?} container\n   */\n  constructor(changeDetectorRef, container) {\n    super(changeDetectorRef, container);\n  }\n}\n\n/** @nocollapse */\n\nclass MatSidenav extends MatDrawer {\n  constructor() {\n    super(...arguments);\n    this._fixedInViewport = false;\n    this._fixedTopGap = 0;\n    this._fixedBottomGap = 0;\n  }\n  /**\n   * Whether the sidenav is fixed in the viewport.\n   * @return {?}\n   */\n  get fixedInViewport() {\n    return this._fixedInViewport;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set fixedInViewport(value) {\n    this._fixedInViewport = coerceBooleanProperty(value);\n  }\n  /**\n   * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n   * mode.\n   * @return {?}\n   */\n  get fixedTopGap() {\n    return this._fixedTopGap;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set fixedTopGap(value) {\n    this._fixedTopGap = coerceNumberProperty(value);\n  }\n  /**\n   * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n   * fixed mode.\n   * @return {?}\n   */\n  get fixedBottomGap() {\n    return this._fixedBottomGap;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set fixedBottomGap(value) {\n    this._fixedBottomGap = coerceNumberProperty(value);\n  }\n}\n\n/** @nocollapse */\n\nclass MatSidenavContainer extends MatDrawerContainer {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatSidenavModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatSidenavModule, throwMatDuplicatedDrawerError, MatDrawerToggleResult, MAT_DRAWER_DEFAULT_AUTOSIZE, MatDrawerContent, MatDrawer, MatDrawerContainer, MatSidenavContent, MatSidenav, MatSidenavContainer, matDrawerAnimations };\n//# sourceMappingURL=sidenav.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}