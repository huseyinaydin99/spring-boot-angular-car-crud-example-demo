{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { A11yModule, FocusKeyManager, FocusMonitor, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { ApplicationRef, ChangeDetectionStrategy, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Inject, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, Self, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { MatCommonModule, MatRippleModule, mixinDisableRipple, mixinDisabled } from '@angular/material/core';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';\nimport { startWith } from 'rxjs/operators/startWith';\nimport { switchMap } from 'rxjs/operators/switchMap';\nimport { take } from 'rxjs/operators/take';\nimport { merge } from 'rxjs/observable/merge';\nimport { Subscription } from 'rxjs/Subscription';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Subject } from 'rxjs/Subject';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { filter } from 'rxjs/operators/filter';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n */\nconst matMenuAnimations = {\n  /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n  transformMenu: trigger('transformMenu', [\n  // TODO(kara): switch to :enter and :leave once Mobile Safari is sorted out.\n  state('void', style({\n    opacity: 0,\n    // This starts off from 0.01, instead of 0, because there's an issue in the Angular animations\n    // as of 4.2, which causes the animation to be skipped if it starts from 0.\n    transform: 'scale(0.01, 0.01)'\n  })), state('enter-start', style({\n    opacity: 1,\n    transform: 'scale(1, 0.5)'\n  })), state('enter', style({\n    transform: 'scale(1, 1)'\n  })), transition('void => enter-start', animate('100ms linear')), transition('enter-start => enter', animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)')), transition('* => void', animate('150ms 50ms linear', style({\n    opacity: 0\n  })))]),\n  /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n  fadeInItems: trigger('fadeInItems', [state('showing', style({\n    opacity: 1\n  })), transition('void => *', [style({\n    opacity: 0\n  }), animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')])])\n};\n/**\n * @deprecated\n * \\@deletion-target 7.0.0\n */\nconst fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@deletion-target 7.0.0\n */\nconst transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n  throw Error(`mat-menu-trigger: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n  throw Error(`x-position value must be either 'before' or after'.\n      Example: <mat-menu x-position=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n  throw Error(`y-position value must be either 'above' or below'.\n      Example: <mat-menu y-position=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\nclass MatMenuItemBase {}\nconst _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nclass MatMenuItem extends _MatMenuItemMixinBase {\n  /**\n   * @param {?} _elementRef\n   * @param {?=} document\n   * @param {?=} _focusMonitor\n   */\n  constructor(_elementRef, document, _focusMonitor) {\n    // @deletion-target 6.0.0 make `_focusMonitor` and `document` required params.\n    super();\n    this._elementRef = _elementRef;\n    this._focusMonitor = _focusMonitor;\n    /**\n     * Stream that emits when the menu item is hovered.\n     */\n    this._hovered = new Subject();\n    /**\n     * Whether the menu item is highlighted.\n     */\n    this._highlighted = false;\n    /**\n     * Whether the menu item acts as a trigger for a sub-menu.\n     */\n    this._triggersSubmenu = false;\n    if (_focusMonitor) {\n      // Start monitoring the element so it gets the appropriate focused classes. We want\n      // to show the focus style for menu items only when the focus was not caused by a\n      // mouse or touch interaction.\n      _focusMonitor.monitor(this._getHostElement(), false);\n    }\n    this._document = document;\n  }\n  /**\n   * Focuses the menu item.\n   * @param {?=} origin\n   * @return {?}\n   */\n  focus(origin = 'program') {\n    if (this._focusMonitor) {\n      this._focusMonitor.focusVia(this._getHostElement(), origin);\n    } else {\n      this._getHostElement().focus();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this._focusMonitor) {\n      this._focusMonitor.stopMonitoring(this._getHostElement());\n    }\n    this._hovered.complete();\n  }\n  /**\n   * Used to set the `tabindex`.\n   * @return {?}\n   */\n  _getTabIndex() {\n    return this.disabled ? '-1' : '0';\n  }\n  /**\n   * Returns the host DOM element.\n   * @return {?}\n   */\n  _getHostElement() {\n    return this._elementRef.nativeElement;\n  }\n  /**\n   * Prevents the default element actions if it is disabled.\n   * @param {?} event\n   * @return {?}\n   */\n  _checkDisabled(event) {\n    if (this.disabled) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  /**\n   * Emits to the hover stream.\n   * @return {?}\n   */\n  _emitHoverEvent() {\n    if (!this.disabled) {\n      this._hovered.next(this);\n    }\n  }\n  /**\n   * Gets the label to be used when determining whether the option should be focused.\n   * @return {?}\n   */\n  getLabel() {\n    const /** @type {?} */element = this._elementRef.nativeElement;\n    const /** @type {?} */textNodeType = this._document ? this._document.TEXT_NODE : 3;\n    let /** @type {?} */output = '';\n    if (element.childNodes) {\n      const /** @type {?} */length = element.childNodes.length;\n      // Go through all the top-level text nodes and extract their text.\n      // We skip anything that's not a text node to prevent the text from\n      // being thrown off by something like an icon.\n      for (let /** @type {?} */i = 0; i < length; i++) {\n        if (element.childNodes[i].nodeType === textNodeType) {\n          output += element.childNodes[i].textContent;\n        }\n      }\n    }\n    return output.trim();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nclass MatMenuContent {\n  /**\n   * @param {?} _template\n   * @param {?} _componentFactoryResolver\n   * @param {?} _appRef\n   * @param {?} _injector\n   * @param {?} _viewContainerRef\n   * @param {?} _document\n   */\n  constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n    this._template = _template;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._injector = _injector;\n    this._viewContainerRef = _viewContainerRef;\n    this._document = _document;\n  }\n  /**\n   * Attaches the content with a particular context.\n   * \\@docs-private\n   * @param {?=} context\n   * @return {?}\n   */\n  attach(context = {}) {\n    if (!this._portal) {\n      this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n    } else if (this._portal.isAttached) {\n      this._portal.detach();\n    }\n    if (!this._outlet) {\n      this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n    }\n    const /** @type {?} */element = this._template.elementRef.nativeElement; /** @type {?} */\n    // Because we support opening the same menu from different triggers (which in turn have their\n    // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n    // risk it staying attached to a pane that's no longer in the DOM.\n    element.parentNode.insertBefore(this._outlet.outletElement, element);\n    this._portal.attach(this._outlet, context);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this._outlet) {\n      this._outlet.dispose();\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default `mat-menu` options that can be overridden.\n * @record\n */\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n */\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options');\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n */\nconst MAT_MENU_BASE_ELEVATION = 2;\nclass MatMenu {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _ngZone\n   * @param {?} _defaultOptions\n   */\n  constructor(_elementRef, _ngZone, _defaultOptions) {\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._defaultOptions = _defaultOptions;\n    this._xPosition = this._defaultOptions.xPosition;\n    this._yPosition = this._defaultOptions.yPosition;\n    /**\n     * Subscription to tab events on the menu panel\n     */\n    this._tabSubscription = Subscription.EMPTY;\n    /**\n     * Config object to be passed into the menu's ngClass\n     */\n    this._classList = {};\n    /**\n     * Current state of the panel animation.\n     */\n    this._panelAnimationState = 'void';\n    this._overlapTrigger = this._defaultOptions.overlapTrigger;\n    /**\n     * Event emitted when the menu is closed.\n     */\n    this.closed = new EventEmitter();\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * \\@deletion-target 6.0.0\n     */\n    this.close = this.closed;\n  }\n  /**\n   * Position of the menu in the X axis.\n   * @return {?}\n   */\n  get xPosition() {\n    return this._xPosition;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set xPosition(value) {\n    if (value !== 'before' && value !== 'after') {\n      throwMatMenuInvalidPositionX();\n    }\n    this._xPosition = value;\n    this.setPositionClasses();\n  }\n  /**\n   * Position of the menu in the Y axis.\n   * @return {?}\n   */\n  get yPosition() {\n    return this._yPosition;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set yPosition(value) {\n    if (value !== 'above' && value !== 'below') {\n      throwMatMenuInvalidPositionY();\n    }\n    this._yPosition = value;\n    this.setPositionClasses();\n  }\n  /**\n   * Whether the menu should overlap its trigger.\n   * @return {?}\n   */\n  get overlapTrigger() {\n    return this._overlapTrigger;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set overlapTrigger(value) {\n    this._overlapTrigger = coerceBooleanProperty(value);\n  }\n  /**\n   * This method takes classes set on the host mat-menu element and applies them on the\n   * menu template that displays in the overlay container.  Otherwise, it's difficult\n   * to style the containing menu from outside the component.\n   * @param {?} classes list of class names\n   * @return {?}\n   */\n  set panelClass(classes) {\n    if (classes && classes.length) {\n      this._classList = classes.split(' ').reduce((obj, className) => {\n        obj[className] = true;\n        return obj;\n      }, {});\n      this._elementRef.nativeElement.className = '';\n      this.setPositionClasses();\n    }\n  }\n  /**\n   * This method takes classes set on the host mat-menu element and applies them on the\n   * menu template that displays in the overlay container.  Otherwise, it's difficult\n   * to style the containing menu from outside the component.\n   * @deprecated Use `panelClass` instead.\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get classList() {\n    return this.panelClass;\n  }\n  /**\n   * @param {?} classes\n   * @return {?}\n   */\n  set classList(classes) {\n    this.panelClass = classes;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._keyManager = new FocusKeyManager(this.items).withWrap().withTypeAhead();\n    this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.close.emit('keydown'));\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._tabSubscription.unsubscribe();\n    this.closed.complete();\n  }\n  /**\n   * Stream that emits whenever the hovered menu item changes.\n   * @return {?}\n   */\n  _hovered() {\n    if (this.items) {\n      return this.items.changes.pipe(startWith(this.items), switchMap(items => merge(...items.map(item => item._hovered))));\n    }\n    return this._ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this._hovered()));\n  }\n  /**\n   * Handle a keyboard event from the menu, delegating to the appropriate action.\n   * @param {?} event\n   * @return {?}\n   */\n  _handleKeydown(event) {\n    switch (event.keyCode) {\n      case ESCAPE:\n        this.closed.emit('keydown');\n        event.stopPropagation();\n        break;\n      case LEFT_ARROW:\n        if (this.parentMenu && this.direction === 'ltr') {\n          this.closed.emit('keydown');\n        }\n        break;\n      case RIGHT_ARROW:\n        if (this.parentMenu && this.direction === 'rtl') {\n          this.closed.emit('keydown');\n        }\n        break;\n      default:\n        this._keyManager.onKeydown(event);\n    }\n  }\n  /**\n   * Focus the first item in the menu.\n   * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n   * @return {?}\n   */\n  focusFirstItem(origin = 'program') {\n    // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n    if (this.lazyContent) {\n      this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this._keyManager.setFocusOrigin(origin).setFirstItemActive());\n    } else {\n      this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n    }\n  }\n  /**\n   * Resets the active item in the menu. This is used when the menu is opened, allowing\n   * the user to start from the first option when pressing the down arrow.\n   * @return {?}\n   */\n  resetActiveItem() {\n    this._keyManager.setActiveItem(-1);\n  }\n  /**\n   * It's necessary to set position-based classes to ensure the menu panel animation\n   * folds out from the correct direction.\n   * @param {?=} posX\n   * @param {?=} posY\n   * @return {?}\n   */\n  setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n    this._classList['mat-menu-before'] = posX === 'before';\n    this._classList['mat-menu-after'] = posX === 'after';\n    this._classList['mat-menu-above'] = posY === 'above';\n    this._classList['mat-menu-below'] = posY === 'below';\n  }\n  /**\n   * Sets the menu panel elevation.\n   * @param {?} depth Number of parent menus that come before the menu.\n   * @return {?}\n   */\n  setElevation(depth) {\n    // The elevation starts at the base and increases by one for each level.\n    const /** @type {?} */newElevation = `mat-elevation-z${MAT_MENU_BASE_ELEVATION + depth}`;\n    const /** @type {?} */customElevation = Object.keys(this._classList).find(c => c.startsWith('mat-elevation-z'));\n    if (!customElevation || customElevation === this._previousElevation) {\n      if (this._previousElevation) {\n        this._classList[this._previousElevation] = false;\n      }\n      this._classList[newElevation] = true;\n      this._previousElevation = newElevation;\n    }\n  }\n  /**\n   * Starts the enter animation.\n   * @return {?}\n   */\n  _startAnimation() {\n    this._panelAnimationState = 'enter-start';\n  }\n  /**\n   * Resets the panel animation to its initial state.\n   * @return {?}\n   */\n  _resetAnimation() {\n    this._panelAnimationState = 'void';\n  }\n  /**\n   * Callback that is invoked when the panel animation completes.\n   * @param {?} event\n   * @return {?}\n   */\n  _onAnimationDone(event) {\n    // After the initial expansion is done, trigger the second phase of the enter animation.\n    if (event.toState === 'enter-start') {\n      this._panelAnimationState = 'enter';\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token that determines the scroll handling while the menu is open.\n */\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/**\n * \\@docs-private\n */\nconst MAT_MENU_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_MENU_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Default top padding of the menu panel.\n */\nconst MENU_PANEL_TOP_PADDING = 8;\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nclass MatMenuTrigger {\n  /**\n   * @param {?} _overlay\n   * @param {?} _element\n   * @param {?} _viewContainerRef\n   * @param {?} _scrollStrategy\n   * @param {?} _parentMenu\n   * @param {?} _menuItemInstance\n   * @param {?} _dir\n   * @param {?=} _focusMonitor\n   */\n  constructor(_overlay, _element, _viewContainerRef, _scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n    this._overlay = _overlay;\n    this._element = _element;\n    this._viewContainerRef = _viewContainerRef;\n    this._scrollStrategy = _scrollStrategy;\n    this._parentMenu = _parentMenu;\n    this._menuItemInstance = _menuItemInstance;\n    this._dir = _dir;\n    this._focusMonitor = _focusMonitor;\n    this._overlayRef = null;\n    this._menuOpen = false;\n    this._closeSubscription = Subscription.EMPTY;\n    this._hoverSubscription = Subscription.EMPTY;\n    this._openedByMouse = false;\n    /**\n     * Event emitted when the associated menu is opened.\n     */\n    this.menuOpened = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * \\@deletion-target 6.0.0\n     */\n    this.onMenuOpen = this.menuOpened;\n    /**\n     * Event emitted when the associated menu is closed.\n     */\n    this.menuClosed = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * \\@deletion-target 6.0.0\n     */\n    this.onMenuClose = this.menuClosed;\n    if (_menuItemInstance) {\n      _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n    }\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedMatMenuTriggerFor() {\n    return this.menu;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set _deprecatedMatMenuTriggerFor(v) {\n    this.menu = v;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._checkMenu();\n    this.menu.close.subscribe(reason => {\n      this._destroyMenu();\n      // If a click closed the menu, we should close the entire chain of nested menus.\n      if (reason === 'click' && this._parentMenu) {\n        this._parentMenu.closed.emit(reason);\n      }\n    });\n    if (this.triggersSubmenu()) {\n      // Subscribe to changes in the hovered item in order to toggle the panel.\n      this._hoverSubscription = this._parentMenu._hovered().pipe(filter(active => active === this._menuItemInstance)).subscribe(() => {\n        this._openedByMouse = true;\n        this.openMenu();\n      });\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n    this._cleanUpSubscriptions();\n  }\n  /**\n   * Whether the menu is open.\n   * @return {?}\n   */\n  get menuOpen() {\n    return this._menuOpen;\n  }\n  /**\n   * The text direction of the containing app.\n   * @return {?}\n   */\n  get dir() {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n  /**\n   * Whether the menu triggers a sub-menu or a top-level one.\n   * @return {?}\n   */\n  triggersSubmenu() {\n    return !!(this._menuItemInstance && this._parentMenu);\n  }\n  /**\n   * Toggles the menu between the open and closed states.\n   * @return {?}\n   */\n  toggleMenu() {\n    return this._menuOpen ? this.closeMenu() : this.openMenu();\n  }\n  /**\n   * Opens the menu.\n   * @return {?}\n   */\n  openMenu() {\n    if (this._menuOpen) {\n      return;\n    }\n    this._createOverlay().attach(this._portal);\n    if (this.menu.lazyContent) {\n      this.menu.lazyContent.attach(this.menuData);\n    }\n    this._closeSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\n    this._initMenu();\n    if (this.menu instanceof MatMenu) {\n      this.menu._startAnimation();\n    }\n  }\n  /**\n   * Closes the menu.\n   * @return {?}\n   */\n  closeMenu() {\n    this.menu.close.emit();\n  }\n  /**\n   * Focuses the menu trigger.\n   * @param {?=} origin Source of the menu trigger's focus.\n   * @return {?}\n   */\n  focus(origin = 'program') {\n    if (this._focusMonitor) {\n      this._focusMonitor.focusVia(this._element.nativeElement, origin);\n    } else {\n      this._element.nativeElement.focus();\n    }\n  }\n  /**\n   * Closes the menu and does the necessary cleanup.\n   * @return {?}\n   */\n  _destroyMenu() {\n    if (this._overlayRef && this.menuOpen) {\n      this._resetMenu();\n      this._closeSubscription.unsubscribe();\n      this._overlayRef.detach();\n      if (this.menu instanceof MatMenu) {\n        this.menu._resetAnimation();\n      }\n    }\n  }\n  /**\n   * This method sets the menu state to open and focuses the first item if\n   * the menu was opened via the keyboard.\n   * @return {?}\n   */\n  _initMenu() {\n    this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n    this.menu.direction = this.dir;\n    this._setMenuElevation();\n    this._setIsMenuOpen(true);\n    this.menu.focusFirstItem(this._openedByMouse ? 'mouse' : 'program');\n  }\n  /**\n   * Updates the menu elevation based on the amount of parent menus that it has.\n   * @return {?}\n   */\n  _setMenuElevation() {\n    if (this.menu.setElevation) {\n      let /** @type {?} */depth = 0;\n      let /** @type {?} */parentMenu = this.menu.parentMenu;\n      while (parentMenu) {\n        depth++;\n        parentMenu = parentMenu.parentMenu;\n      }\n      this.menu.setElevation(depth);\n    }\n  }\n  /**\n   * This method resets the menu when it's closed, most importantly restoring\n   * focus to the menu trigger if the menu was opened via the keyboard.\n   * @return {?}\n   */\n  _resetMenu() {\n    this._setIsMenuOpen(false);\n    // We should reset focus if the user is navigating using a keyboard or\n    // if we have a top-level trigger which might cause focus to be lost\n    // when clicking on the backdrop.\n    if (!this._openedByMouse) {\n      // Note that the focus style will show up both for `program` and\n      // `keyboard` so we don't have to specify which one it is.\n      this.focus();\n    } else if (!this.triggersSubmenu()) {\n      this.focus('mouse');\n    }\n    this._openedByMouse = false;\n  }\n  /**\n   * @param {?} isOpen\n   * @return {?}\n   */\n  _setIsMenuOpen(isOpen) {\n    this._menuOpen = isOpen;\n    this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n    if (this.triggersSubmenu()) {\n      this._menuItemInstance._highlighted = isOpen;\n    }\n  }\n  /**\n   * This method checks that a valid instance of MatMenu has been passed into\n   * matMenuTriggerFor. If not, an exception is thrown.\n   * @return {?}\n   */\n  _checkMenu() {\n    if (!this.menu) {\n      throwMatMenuMissingError();\n    }\n  }\n  /**\n   * This method creates the overlay from the provided menu's template and saves its\n   * OverlayRef so that it can be attached to the DOM when openMenu is called.\n   * @return {?}\n   */\n  _createOverlay() {\n    if (!this._overlayRef) {\n      this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n      const /** @type {?} */config = this._getOverlayConfig();\n      this._subscribeToPositions( /** @type {?} */config.positionStrategy);\n      this._overlayRef = this._overlay.create(config);\n    }\n    return this._overlayRef;\n  }\n  /**\n   * This method builds the configuration object needed to create the overlay, the OverlayState.\n   * @return {?} OverlayConfig\n   */\n  _getOverlayConfig() {\n    return new OverlayConfig({\n      positionStrategy: this._getPosition(),\n      hasBackdrop: !this.triggersSubmenu(),\n      backdropClass: 'cdk-overlay-transparent-backdrop',\n      direction: this.dir,\n      scrollStrategy: this._scrollStrategy()\n    });\n  }\n  /**\n   * Listens to changes in the position of the overlay and sets the correct classes\n   * on the menu based on the new position. This ensures the animation origin is always\n   * correct, even if a fallback position is used for the overlay.\n   * @param {?} position\n   * @return {?}\n   */\n  _subscribeToPositions(position) {\n    position.onPositionChange.subscribe(change => {\n      const /** @type {?} */posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n      const /** @type {?} */posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n      this.menu.setPositionClasses(posX, posY);\n    });\n  }\n  /**\n   * This method builds the position strategy for the overlay, so the menu is properly connected\n   * to the trigger.\n   * @return {?} ConnectedPositionStrategy\n   */\n  _getPosition() {\n    let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n    let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n    let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n    let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n    let /** @type {?} */offsetY = 0;\n    if (this.triggersSubmenu()) {\n      // When the menu is a sub-menu, it should always align itself\n      // to the edges of the trigger, instead of overlapping it.\n      overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n      originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n      offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n    } else if (!this.menu.overlapTrigger) {\n      originY = overlayY === 'top' ? 'bottom' : 'top';\n      originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n    }\n    return this._overlay.position().connectedTo(this._element, {\n      originX,\n      originY\n    }, {\n      overlayX,\n      overlayY\n    }).withDirection(this.dir).withOffsetY(offsetY).withFallbackPosition({\n      originX: originFallbackX,\n      originY\n    }, {\n      overlayX: overlayFallbackX,\n      overlayY\n    }).withFallbackPosition({\n      originX,\n      originY: originFallbackY\n    }, {\n      overlayX,\n      overlayY: overlayFallbackY\n    }, undefined, -offsetY).withFallbackPosition({\n      originX: originFallbackX,\n      originY: originFallbackY\n    }, {\n      overlayX: overlayFallbackX,\n      overlayY: overlayFallbackY\n    }, undefined, -offsetY);\n  }\n  /**\n   * Cleans up the active subscriptions.\n   * @return {?}\n   */\n  _cleanUpSubscriptions() {\n    this._closeSubscription.unsubscribe();\n    this._hoverSubscription.unsubscribe();\n  }\n  /**\n   * Returns a stream that emits whenever an action that should close the menu occurs.\n   * @return {?}\n   */\n  _menuClosingActions() {\n    const /** @type {?} */backdrop = /** @type {?} */this._overlayRef.backdropClick();\n    const /** @type {?} */detachments = /** @type {?} */this._overlayRef.detachments();\n    const /** @type {?} */parentClose = this._parentMenu ? this._parentMenu.close : of();\n    const /** @type {?} */hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(active => active !== this._menuItemInstance), filter(() => this._menuOpen)) : of();\n    return merge(backdrop, parentClose, hover, detachments);\n  }\n  /**\n   * Handles mouse presses on the trigger.\n   * @param {?} event\n   * @return {?}\n   */\n  _handleMousedown(event) {\n    if (!isFakeMousedownFromScreenReader(event)) {\n      this._openedByMouse = true;\n      // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n      // we should prevent focus from moving onto it via click to avoid the\n      // highlight from lingering on the menu item.\n      if (this.triggersSubmenu()) {\n        event.preventDefault();\n      }\n    }\n  }\n  /**\n   * Handles key presses on the trigger.\n   * @param {?} event\n   * @return {?}\n   */\n  _handleKeydown(event) {\n    const /** @type {?} */keyCode = event.keyCode;\n    if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === 'ltr' || keyCode === LEFT_ARROW && this.dir === 'rtl')) {\n      this.openMenu();\n    }\n  }\n  /**\n   * Handles click events on the trigger.\n   * @param {?} event\n   * @return {?}\n   */\n  _handleClick(event) {\n    if (this.triggersSubmenu()) {\n      // Stop event propagation to avoid closing the parent menu.\n      event.stopPropagation();\n      this.openMenu();\n    } else {\n      this.toggleMenu();\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nconst ɵ0 = {\n  overlapTrigger: true,\n  xPosition: 'after',\n  yPosition: 'below'\n};\nclass MatMenuModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MatMenuItemBase as ɵa21, _MatMenuItemMixinBase as ɵb21, MAT_MENU_SCROLL_STRATEGY_PROVIDER as ɵd21, MAT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY as ɵc21 };\n//# sourceMappingURL=menu.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}