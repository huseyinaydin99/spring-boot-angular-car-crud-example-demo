{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgModule, Output, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { GestureConfig, MatCommonModule, MatRipple, MatRippleModule, mixinColor, mixinDisableRipple, mixinDisabled, mixinTabIndex } from '@angular/material/core';\nimport { HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\nimport { A11yModule, FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Increasing integer for generating unique ids for slide-toggle components.\nlet nextUniqueId = 0;\nconst MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatSlideToggle),\n  multi: true\n};\n/**\n * Change event object emitted by a MatSlideToggle.\n */\nclass MatSlideToggleChange {\n  /**\n   * @param {?} source\n   * @param {?} checked\n   */\n  constructor(source, checked) {\n    this.source = source;\n    this.checked = checked;\n  }\n}\n/**\n * \\@docs-private\n */\nclass MatSlideToggleBase {\n  /**\n   * @param {?} _elementRef\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n}\nconst _MatSlideToggleMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatSlideToggleBase)), 'accent'));\n/**\n * Represents a slidable \"switch\" toggle that can be moved between on and off.\n */\nclass MatSlideToggle extends _MatSlideToggleMixinBase {\n  /**\n   * @param {?} elementRef\n   * @param {?} _platform\n   * @param {?} _focusMonitor\n   * @param {?} _changeDetectorRef\n   * @param {?} tabIndex\n   */\n  constructor(elementRef, _platform, _focusMonitor, _changeDetectorRef, tabIndex) {\n    super(elementRef);\n    this._platform = _platform;\n    this._focusMonitor = _focusMonitor;\n    this._changeDetectorRef = _changeDetectorRef;\n    this.onChange = _ => {};\n    this.onTouched = () => {};\n    this._uniqueId = `mat-slide-toggle-${++nextUniqueId}`;\n    this._required = false;\n    this._checked = false;\n    /**\n     * Name value will be applied to the input element if present\n     */\n    this.name = null;\n    /**\n     * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\n     */\n    this.id = this._uniqueId;\n    /**\n     * Whether the label should appear after or before the slide-toggle. Defaults to 'after'\n     */\n    this.labelPosition = 'after';\n    /**\n     * Used to set the aria-label attribute on the underlying input element.\n     */\n    this.ariaLabel = null;\n    /**\n     * Used to set the aria-labelledby attribute on the underlying input element.\n     */\n    this.ariaLabelledby = null;\n    /**\n     * An event will be dispatched each time the slide-toggle changes its value.\n     */\n    this.change = new EventEmitter();\n    this.tabIndex = parseInt(tabIndex) || 0;\n  }\n  /**\n   * Whether the slide-toggle is required.\n   * @return {?}\n   */\n  get required() {\n    return this._required;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether the slide-toggle element is checked or not\n   * @return {?}\n   */\n  get checked() {\n    return this._checked;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set checked(value) {\n    this._checked = coerceBooleanProperty(value);\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Returns the unique id for the visual hidden input.\n   * @return {?}\n   */\n  get inputId() {\n    return `${this.id || this._uniqueId}-input`;\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._slideRenderer = new SlideToggleRenderer(this._elementRef, this._platform);\n    this._focusMonitor.monitor(this._inputElement.nativeElement).subscribe(focusOrigin => this._onInputFocusChange(focusOrigin));\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._inputElement.nativeElement);\n  }\n  /**\n   * Method being called whenever the underlying input emits a change event.\n   * @param {?} event\n   * @return {?}\n   */\n  _onChangeEvent(event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the component's `change` output.\n    event.stopPropagation();\n    // Releasing the pointer over the `<label>` element while dragging triggers another\n    // click event on the `<label>` element. This means that the checked state of the underlying\n    // input changed unintentionally and needs to be changed back.\n    if (this._slideRenderer.dragging) {\n      this._inputElement.nativeElement.checked = this.checked;\n      return;\n    }\n    // Sync the value from the underlying input element with the component instance.\n    this.checked = this._inputElement.nativeElement.checked;\n    // Emit our custom change event only if the underlying input emitted one. This ensures that\n    // there is no change event, when the checked state changes programmatically.\n    this._emitChangeEvent();\n  }\n  /**\n   * Method being called whenever the slide-toggle has been clicked.\n   * @param {?} event\n   * @return {?}\n   */\n  _onInputClick(event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `slide-toggle` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    this.checked = !!value;\n  }\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  /**\n   * Implemented as a part of ControlValueAccessor.\n   * @param {?} isDisabled\n   * @return {?}\n   */\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Focuses the slide-toggle.\n   * @return {?}\n   */\n  focus() {\n    this._focusMonitor.focusVia(this._inputElement.nativeElement, 'keyboard');\n  }\n  /**\n   * Toggles the checked state of the slide-toggle.\n   * @return {?}\n   */\n  toggle() {\n    this.checked = !this.checked;\n  }\n  /**\n   * Function is called whenever the focus changes for the input element.\n   * @param {?} focusOrigin\n   * @return {?}\n   */\n  _onInputFocusChange(focusOrigin) {\n    if (!this._focusRipple && focusOrigin === 'keyboard') {\n      // For keyboard focus show a persistent ripple as focus indicator.\n      this._focusRipple = this._ripple.launch(0, 0, {\n        persistent: true\n      });\n    } else if (!focusOrigin) {\n      this.onTouched();\n      // Fade out and clear the focus ripple if one is currently present.\n      if (this._focusRipple) {\n        this._focusRipple.fadeOut();\n        this._focusRipple = null;\n      }\n    }\n  }\n  /**\n   * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    this.onChange(this.checked);\n    this.change.emit(new MatSlideToggleChange(this, this.checked));\n  }\n  /**\n   * @return {?}\n   */\n  _onDragStart() {\n    if (!this.disabled) {\n      this._slideRenderer.startThumbDrag(this.checked);\n    }\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onDrag(event) {\n    if (this._slideRenderer.dragging) {\n      this._slideRenderer.updateThumbPosition(event.deltaX);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _onDragEnd() {\n    if (this._slideRenderer.dragging) {\n      const /** @type {?} */newCheckedValue = this._slideRenderer.dragPercentage > 50;\n      if (newCheckedValue !== this.checked) {\n        this.checked = newCheckedValue;\n        this._emitChangeEvent();\n      }\n      // The drag should be stopped outside of the current event handler, because otherwise the\n      // click event will be fired before and will revert the drag change.\n      setTimeout(() => this._slideRenderer.stopThumbDrag());\n    }\n  }\n  /**\n   * Method being called whenever the label text changes.\n   * @return {?}\n   */\n  _onLabelTextChange() {\n    // This method is getting called whenever the label of the slide-toggle changes.\n    // Since the slide-toggle uses the OnPush strategy we need to notify it about the change\n    // that has been recognized by the cdkObserveContent directive.\n    this._changeDetectorRef.markForCheck();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Renderer for the Slide Toggle component, which separates DOM modification in its own class\n */\nclass SlideToggleRenderer {\n  /**\n   * @param {?} elementRef\n   * @param {?} platform\n   */\n  constructor(elementRef, platform) {\n    /**\n     * Whether the thumb is currently being dragged.\n     */\n    this.dragging = false;\n    // We only need to interact with these elements when we're on the browser, so only grab\n    // the reference in that case.\n    if (platform.isBrowser) {\n      this._thumbEl = elementRef.nativeElement.querySelector('.mat-slide-toggle-thumb-container');\n      this._thumbBarEl = elementRef.nativeElement.querySelector('.mat-slide-toggle-bar');\n    }\n  }\n  /**\n   * Initializes the drag of the slide-toggle.\n   * @param {?} checked\n   * @return {?}\n   */\n  startThumbDrag(checked) {\n    if (this.dragging) {\n      return;\n    }\n    this._thumbBarWidth = this._thumbBarEl.clientWidth - this._thumbEl.clientWidth;\n    this._thumbEl.classList.add('mat-dragging');\n    this._previousChecked = checked;\n    this.dragging = true;\n  }\n  /**\n   * Resets the current drag and returns the new checked value.\n   * @return {?}\n   */\n  stopThumbDrag() {\n    if (!this.dragging) {\n      return false;\n    }\n    this.dragging = false;\n    this._thumbEl.classList.remove('mat-dragging');\n    // Reset the transform because the component will take care of the thumb position after drag.\n    this._thumbEl.style.transform = '';\n    return this.dragPercentage > 50;\n  }\n  /**\n   * Updates the thumb containers position from the specified distance.\n   * @param {?} distance\n   * @return {?}\n   */\n  updateThumbPosition(distance) {\n    this.dragPercentage = this._getDragPercentage(distance);\n    // Calculate the moved distance based on the thumb bar width.\n    const /** @type {?} */dragX = this.dragPercentage / 100 * this._thumbBarWidth;\n    this._thumbEl.style.transform = `translate3d(${dragX}px, 0, 0)`;\n  }\n  /**\n   * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.\n   * @param {?} distance\n   * @return {?}\n   */\n  _getDragPercentage(distance) {\n    let /** @type {?} */percentage = distance / this._thumbBarWidth * 100;\n    // When the toggle was initially checked, then we have to start the drag at the end.\n    if (this._previousChecked) {\n      percentage += 100;\n    }\n    return Math.max(0, Math.min(percentage, 100));\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatSlideToggleModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggleBase, _MatSlideToggleMixinBase, MatSlideToggle };\n//# sourceMappingURL=slide-toggle.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}