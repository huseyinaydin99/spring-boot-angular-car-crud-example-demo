{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, Input, IterableDiffers, NgModule, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation, isDevMode } from '@angular/core';\nimport { DataSource } from '@angular/cdk/collections';\nimport { takeUntil } from 'rxjs/operators/takeUntil';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { of } from 'rxjs/observable/of';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * The row template that can be used by the mat-table. Should not be used outside of the\n * material library.\n */\nconst CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;\n/**\n * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs\n * for changes and notifying the table.\n * @abstract\n */\nclass BaseRowDef {\n  /**\n   * @param {?} template\n   * @param {?} _differs\n   */\n  constructor(template, _differs) {\n    this.template = template;\n    this._differs = _differs;\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    // Create a new columns differ if one does not yet exist. Initialize it based on initial value\n    // of the columns property or an empty array if none is provided.\n    const /** @type {?} */columns = changes['columns'].currentValue || [];\n    if (!this._columnsDiffer) {\n      this._columnsDiffer = this._differs.find(columns).create();\n      this._columnsDiffer.diff(columns);\n    }\n  }\n  /**\n   * Returns the difference between the current columns and the columns from the last diff, or null\n   * if there is no difference.\n   * @return {?}\n   */\n  getColumnsDiff() {\n    return this._columnsDiffer.diff(this.columns);\n  }\n}\n/**\n * Header row definition for the CDK table.\n * Captures the header row's template and other header properties such as the columns to display.\n */\nclass CdkHeaderRowDef extends BaseRowDef {\n  /**\n   * @param {?} template\n   * @param {?} _differs\n   */\n  constructor(template, _differs) {\n    super(template, _differs);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Data row definition for the CDK table.\n * Captures the header row's template and other row properties such as the columns to display and\n * a when predicate that describes when this row should be used.\n * @template T\n */\nclass CdkRowDef extends BaseRowDef {\n  /**\n   * @param {?} template\n   * @param {?} _differs\n   */\n  constructor(template, _differs) {\n    super(template, _differs);\n  }\n}\n\n/** @nocollapse */\n/**\n * Context provided to the row cells\n * @record\n * @template T\n */\n/**\n * Outlet for rendering cells inside of a row or header row.\n * \\@docs-private\n */\nlet CdkCellOutlet = /*#__PURE__*/(() => {\n  class CdkCellOutlet {\n    /**\n     * @param {?} _viewContainer\n     */\n    constructor(_viewContainer) {\n      this._viewContainer = _viewContainer;\n      CdkCellOutlet.mostRecentCellOutlet = this;\n    }\n  }\n  /**\n   * Static property containing the latest constructed instance of this class.\n   * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using\n   * createEmbeddedView. After one of these components are created, this property will provide\n   * a handle to provide that component's cells and context. After init, the CdkCellOutlet will\n   * construct the cells with the provided context.\n   */\n  CdkCellOutlet.mostRecentCellOutlet = null;\n\n  /** @nocollapse */\n  return CdkCellOutlet;\n})();\n/**\n * Header template container that contains the cell outlet. Adds the right class and role.\n */\nclass CdkHeaderRow {}\n\n/** @nocollapse */\n\n/**\n * Data row template container that contains the cell outlet. Adds the right class and role.\n */\nclass CdkRow {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cell definition for a CDK table.\n * Captures the template of a column's data row cell as well as cell-specific properties.\n */\nclass CdkCellDef {\n  /**\n   * @param {?} template\n   */\n  constructor(template) {\n    this.template = template;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Header cell definition for a CDK table.\n * Captures the template of a column's header cell and as well as cell-specific properties.\n */\nclass CdkHeaderCellDef {\n  /**\n   * @param {?} template\n   */\n  constructor(template) {\n    this.template = template;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Column definition for the CDK table.\n * Defines a set of cells available for a table column.\n */\nclass CdkColumnDef {\n  /**\n   * Unique name for this column.\n   * @return {?}\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n  set name(name) {\n    // If the directive is set without a name (updated programatically), then this setter will\n    // trigger with an empty string and should not overwrite the programatically set value.\n    if (!name) {\n      return;\n    }\n    this._name = name;\n    this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Header cell template container that adds the right classes and role.\n */\nclass CdkHeaderCell {\n  /**\n   * @param {?} columnDef\n   * @param {?} elementRef\n   */\n  constructor(columnDef, elementRef) {\n    elementRef.nativeElement.classList.add(`cdk-column-${columnDef.cssClassFriendlyName}`);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Cell template container that adds the right classes and role.\n */\nclass CdkCell {\n  /**\n   * @param {?} columnDef\n   * @param {?} elementRef\n   */\n  constructor(columnDef, elementRef) {\n    elementRef.nativeElement.classList.add(`cdk-column-${columnDef.cssClassFriendlyName}`);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Returns an error to be thrown when attempting to find an unexisting column.\n * \\@docs-private\n * @param {?} id Id whose lookup failed.\n * @return {?}\n */\nfunction getTableUnknownColumnError(id) {\n  return Error(`Could not find column with id \"${id}\".`);\n}\n/**\n * Returns an error to be thrown when two column definitions have the same name.\n * \\@docs-private\n * @param {?} name\n * @return {?}\n */\nfunction getTableDuplicateColumnNameError(name) {\n  return Error(`Duplicate column definition name provided: \"${name}\".`);\n}\n/**\n * Returns an error to be thrown when there are multiple rows that are missing a when function.\n * \\@docs-private\n * @return {?}\n */\nfunction getTableMultipleDefaultRowDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching row defs for a particular set of data.\n * \\@docs-private\n * @return {?}\n */\nfunction getTableMissingMatchingRowDefError() {\n  return Error(`Could not find a matching row definition for the provided row data.`);\n}\n/**\n * Returns an error to be thrown when there is no row definitions present in the content.\n * \\@docs-private\n * @return {?}\n */\nfunction getTableMissingRowDefsError() {\n  return Error('Missing definitions for header and row, ' + 'cannot determine which columns should be rendered.');\n}\n/**\n * Returns an error to be thrown when the data source does not match the compatible types.\n * \\@docs-private\n * @return {?}\n */\nfunction getTableUnknownDataSourceError() {\n  return Error(`Provided data source did not match an array, Observable, or DataSource`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert data rows.\n * \\@docs-private\n */\nclass RowPlaceholder {\n  /**\n   * @param {?} viewContainer\n   */\n  constructor(viewContainer) {\n    this.viewContainer = viewContainer;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert the header.\n * \\@docs-private\n */\nclass HeaderRowPlaceholder {\n  /**\n   * @param {?} viewContainer\n   */\n  constructor(viewContainer) {\n    this.viewContainer = viewContainer;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * The table template that can be used by the mat-table. Should not be used outside of the\n * material library.\n */\nconst CDK_TABLE_TEMPLATE = `\n  <ng-container headerRowPlaceholder></ng-container>\n  <ng-container rowPlaceholder></ng-container>`;\n/**\n * A data table that renders a header row and data rows. Uses the dataSource input to determine\n * the data to be rendered. The data can be provided either as a data array, an Observable stream\n * that emits the data array to render, or a DataSource with a connect function that will\n * return an Observable stream that emits the data array to render.\n * @template T\n */\nclass CdkTable {\n  /**\n   * @param {?} _differs\n   * @param {?} _changeDetectorRef\n   * @param {?} elementRef\n   * @param {?} role\n   */\n  constructor(_differs, _changeDetectorRef, elementRef, role) {\n    this._differs = _differs;\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n    this._onDestroy = new Subject();\n    /**\n     * Map of all the user's defined columns (header and data cell template) identified by name.\n     * Collection populated by the column definitions gathered by `ContentChildren` as well as any\n     * custom column definitions added to `_customColumnDefs`.\n     */\n    this._columnDefsByName = new Map();\n    /**\n     * Column definitions that were defined outside of the direct content children of the table.\n     */\n    this._customColumnDefs = new Set();\n    /**\n     * Row definitions that were defined outside of the direct content children of the table.\n     */\n    this._customRowDefs = new Set();\n    /**\n     * Whether the header row definition has been changed. Triggers an update to the header row after\n     * content is checked.\n     */\n    this._headerRowDefChanged = false;\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    this.viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    if (!role) {\n      elementRef.nativeElement.setAttribute('role', 'grid');\n    }\n  }\n  /**\n   * Tracking function that will be used to check the differences in data changes. Used similarly\n   * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\n   * relative to the function to know if a row should be added/removed/moved.\n   * Accepts a function that takes two parameters, `index` and `item`.\n   * @return {?}\n   */\n  get trackBy() {\n    return this._trackByFn;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  set trackBy(fn) {\n    if (isDevMode() && fn != null && typeof fn !== 'function' && /** @type {?} */console && /** @type {?} */console.warn) {\n      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\n    }\n    this._trackByFn = fn;\n  }\n  /**\n   * The table's source of data, which can be provided in three ways (in order of complexity):\n   *   - Simple data array (each object represents one table row)\n   *   - Stream that emits a data array each time the array changes\n   *   - `DataSource` object that implements the connect/disconnect interface.\n   *\n   * If a data array is provided, the table must be notified when the array's objects are\n   * added, removed, or moved. This can be done by calling the `renderRows()` function which will\n   * render the diff since the last table render. If the data array reference is changed, the table\n   * will automatically trigger an update to the rows.\n   *\n   * When providing an Observable stream, the table will trigger an update automatically when the\n   * stream emits a new array of data.\n   *\n   * Finally, when providing a `DataSource` object, the table will use the Observable stream\n   * provided by the connect function and trigger updates when that stream emits new data array\n   * values. During the table's ngOnDestroy or when the data source is removed from the table, the\n   * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\n   * subscriptions registered during the connect process).\n   * @return {?}\n   */\n  get dataSource() {\n    return this._dataSource;\n  }\n  /**\n   * @param {?} dataSource\n   * @return {?}\n   */\n  set dataSource(dataSource) {\n    if (this._dataSource !== dataSource) {\n      this._switchDataSource(dataSource);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    // TODO(andrewseguin): Setup a listener for scrolling, emit the calculated view to viewChange\n    this._dataDiffer = this._differs.find([]).create(this._trackByFn);\n    // If the table has a header row definition defined as part of its content, flag this as a\n    // header row def change so that the content check will render the header row.\n    if (this._headerRowDef) {\n      this._headerRowDefChanged = true;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentChecked() {\n    // Cache the row and column definitions gathered by ContentChildren and programmatic injection.\n    this._cacheRowDefs();\n    this._cacheColumnDefs();\n    // Make sure that the user has at least added a header row or row def.\n    if (!this._headerRowDef && !this._rowDefs.length) {\n      throw getTableMissingRowDefsError();\n    }\n    // Render updates if the list of columns have been changed for the header or row definitions.\n    this._renderUpdatedColumns();\n    // If the header row definition has been changed, trigger a render to the header row.\n    if (this._headerRowDefChanged) {\n      this._renderHeaderRow();\n      this._headerRowDefChanged = false;\n    }\n    // If there is a data source and row definitions, connect to the data source unless a\n    // connection has already been made.\n    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {\n      this._observeRenderChanges();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._rowPlaceholder.viewContainer.clear();\n    this._headerRowPlaceholder.viewContainer.clear();\n    this._onDestroy.next();\n    this._onDestroy.complete();\n    if (this.dataSource instanceof DataSource) {\n      this.dataSource.disconnect(this);\n    }\n  }\n  /**\n   * Renders rows based on the table's latest set of data, which was either provided directly as an\n   * input or retrieved through an Observable stream (directly or from a DataSource).\n   * Checks for differences in the data since the last diff to perform only the necessary\n   * changes (add/remove/move rows).\n   *\n   * If the table's data source is a DataSource or Observable, this will be invoked automatically\n   * each time the provided Observable stream emits a new data array. Otherwise if your data is\n   * an array, this function will need to be called to render any changes.\n   * @return {?}\n   */\n  renderRows() {\n    const /** @type {?} */changes = this._dataDiffer.diff(this._data);\n    if (!changes) {\n      return;\n    }\n    const /** @type {?} */viewContainer = this._rowPlaceholder.viewContainer;\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      if (record.previousIndex == null) {\n        this._insertRow(record.item, currentIndex);\n      } else if (currentIndex == null) {\n        viewContainer.remove(adjustedPreviousIndex);\n      } else {\n        const /** @type {?} */view = /** @type {?} */viewContainer.get(adjustedPreviousIndex);\n        viewContainer.move( /** @type {?} */view, currentIndex);\n      }\n    });\n    // Update the meta context of a row's context data (index, count, first, last, ...)\n    this._updateRowIndexContext();\n    // Update rows that did not get added/removed/moved but may have had their identity changed,\n    // e.g. if trackBy matched data on some property but the actual data reference changed.\n    changes.forEachIdentityChange(record => {\n      const /** @type {?} */rowView = /** @type {?} */viewContainer.get( /** @type {?} */record.currentIndex);\n      rowView.context.$implicit = record.item;\n    });\n  }\n  /**\n   * Sets the header row definition to be used. Overrides the header row definition gathered by\n   * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the\n   * table's content is checked.\n   * @param {?} headerRowDef\n   * @return {?}\n   */\n  setHeaderRowDef(headerRowDef) {\n    this._headerRowDef = headerRowDef;\n    this._headerRowDefChanged = true;\n  }\n  /**\n   * Adds a column definition that was not included as part of the direct content children.\n   * @param {?} columnDef\n   * @return {?}\n   */\n  addColumnDef(columnDef) {\n    this._customColumnDefs.add(columnDef);\n  }\n  /**\n   * Removes a column definition that was not included as part of the direct content children.\n   * @param {?} columnDef\n   * @return {?}\n   */\n  removeColumnDef(columnDef) {\n    this._customColumnDefs.delete(columnDef);\n  }\n  /**\n   * Adds a row definition that was not included as part of the direct content children.\n   * @param {?} rowDef\n   * @return {?}\n   */\n  addRowDef(rowDef) {\n    this._customRowDefs.add(rowDef);\n  }\n  /**\n   * Removes a row definition that was not included as part of the direct content children.\n   * @param {?} rowDef\n   * @return {?}\n   */\n  removeRowDef(rowDef) {\n    this._customRowDefs.delete(rowDef);\n  }\n  /**\n   * Update the map containing the content's column definitions.\n   * @return {?}\n   */\n  _cacheColumnDefs() {\n    this._columnDefsByName.clear();\n    const /** @type {?} */columnDefs = this._contentColumnDefs ? this._contentColumnDefs.toArray() : [];\n    this._customColumnDefs.forEach(columnDef => columnDefs.push(columnDef));\n    columnDefs.forEach(columnDef => {\n      if (this._columnDefsByName.has(columnDef.name)) {\n        throw getTableDuplicateColumnNameError(columnDef.name);\n      }\n      this._columnDefsByName.set(columnDef.name, columnDef);\n    });\n  }\n  /**\n   * Update the list of all available row definitions that can be used.\n   * @return {?}\n   */\n  _cacheRowDefs() {\n    this._rowDefs = this._contentRowDefs ? this._contentRowDefs.toArray() : [];\n    this._customRowDefs.forEach(rowDef => this._rowDefs.push(rowDef));\n    const /** @type {?} */defaultRowDefs = this._rowDefs.filter(def => !def.when);\n    if (defaultRowDefs.length > 1) {\n      throw getTableMultipleDefaultRowDefsError();\n    }\n    this._defaultRowDef = defaultRowDefs[0];\n  }\n  /**\n   * Check if the header or rows have changed what columns they want to display. If there is a diff,\n   * then re-render that section.\n   * @return {?}\n   */\n  _renderUpdatedColumns() {\n    // Re-render the rows when the row definition columns change.\n    this._rowDefs.forEach(def => {\n      if (!!def.getColumnsDiff()) {\n        // Reset the data to an empty array so that renderRowChanges will re-render all new rows.\n        this._dataDiffer.diff([]);\n        this._rowPlaceholder.viewContainer.clear();\n        this.renderRows();\n      }\n    });\n    // Re-render the header row if there is a difference in its columns.\n    if (this._headerRowDef && this._headerRowDef.getColumnsDiff()) {\n      this._renderHeaderRow();\n    }\n  }\n  /**\n   * Switch to the provided data source by resetting the data and unsubscribing from the current\n   * render change subscription if one exists. If the data source is null, interpret this by\n   * clearing the row placeholder. Otherwise start listening for new data.\n   * @param {?} dataSource\n   * @return {?}\n   */\n  _switchDataSource(dataSource) {\n    this._data = [];\n    if (this.dataSource instanceof DataSource) {\n      this.dataSource.disconnect(this);\n    }\n    // Stop listening for data from the previous data source.\n    if (this._renderChangeSubscription) {\n      this._renderChangeSubscription.unsubscribe();\n      this._renderChangeSubscription = null;\n    }\n    if (!dataSource) {\n      if (this._dataDiffer) {\n        this._dataDiffer.diff([]);\n      }\n      this._rowPlaceholder.viewContainer.clear();\n    }\n    this._dataSource = dataSource;\n  }\n  /**\n   * Set up a subscription for the data provided by the data source.\n   * @return {?}\n   */\n  _observeRenderChanges() {\n    // If no data source has been set, there is nothing to observe for changes.\n    if (!this.dataSource) {\n      return;\n    }\n    let /** @type {?} */dataStream;\n    // Check if the datasource is a DataSource object by observing if it has a connect function.\n    // Cannot check this.dataSource['connect'] due to potential property renaming, nor can it\n    // checked as an instanceof DataSource<T> since the table should allow for data sources\n    // that did not explicitly extend DataSource<T>.\n    if ( /** @type {?} */this.dataSource.connect instanceof Function) {\n      dataStream = /** @type {?} */this.dataSource.connect(this);\n    } else if (this.dataSource instanceof Observable) {\n      dataStream = this.dataSource;\n    } else if (Array.isArray(this.dataSource)) {\n      dataStream = of(this.dataSource);\n    }\n    if (dataStream === undefined) {\n      throw getTableUnknownDataSourceError();\n    }\n    this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe(data => {\n      this._data = data;\n      this.renderRows();\n    });\n  }\n  /**\n   * Clears any existing content in the header row placeholder and creates a new embedded view\n   * in the placeholder using the header row definition.\n   * @return {?}\n   */\n  _renderHeaderRow() {\n    // Clear the header row placeholder if any content exists.\n    if (this._headerRowPlaceholder.viewContainer.length > 0) {\n      this._headerRowPlaceholder.viewContainer.clear();\n    }\n    const /** @type {?} */cells = this._getHeaderCellTemplatesForRow(this._headerRowDef);\n    if (!cells.length) {\n      return;\n    }\n    // TODO(andrewseguin): add some code to enforce that exactly\n    //   one CdkCellOutlet was instantiated as a result\n    //   of `createEmbeddedView`.\n    this._headerRowPlaceholder.viewContainer.createEmbeddedView(this._headerRowDef.template, {\n      cells\n    });\n    cells.forEach(cell => {\n      if (CdkCellOutlet.mostRecentCellOutlet) {\n        CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cell.template, {});\n      }\n    });\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Finds the matching row definition that should be used for this row data. If there is only\n   * one row definition, it is returned. Otherwise, find the row definition that has a when\n   * predicate that returns true with the data. If none return true, return the default row\n   * definition.\n   * @param {?} data\n   * @param {?} i\n   * @return {?}\n   */\n  _getRowDef(data, i) {\n    if (this._rowDefs.length == 1) {\n      return this._rowDefs[0];\n    }\n    let /** @type {?} */rowDef = this._rowDefs.find(def => def.when && def.when(i, data)) || this._defaultRowDef;\n    if (!rowDef) {\n      throw getTableMissingMatchingRowDefError();\n    }\n    return rowDef;\n  }\n  /**\n   * Create the embedded view for the data row template and place it in the correct index location\n   * within the data row view container.\n   * @param {?} rowData\n   * @param {?} index\n   * @return {?}\n   */\n  _insertRow(rowData, index) {\n    const /** @type {?} */row = this._getRowDef(rowData, index);\n    // Row context that will be provided to both the created embedded row view and its cells.\n    const /** @type {?} */context = {\n      $implicit: rowData\n    };\n    // TODO(andrewseguin): add some code to enforce that exactly one\n    //   CdkCellOutlet was instantiated as a result  of `createEmbeddedView`.\n    this._rowPlaceholder.viewContainer.createEmbeddedView(row.template, context, index);\n    this._getCellTemplatesForRow(row).forEach(cell => {\n      if (CdkCellOutlet.mostRecentCellOutlet) {\n        CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cell.template, context);\n      }\n    });\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Updates the index-related context for each row to reflect any changes in the index of the rows,\n   * e.g. first/last/even/odd.\n   * @return {?}\n   */\n  _updateRowIndexContext() {\n    const /** @type {?} */viewContainer = this._rowPlaceholder.viewContainer;\n    for (let /** @type {?} */index = 0, /** @type {?} */count = viewContainer.length; index < count; index++) {\n      const /** @type {?} */viewRef = /** @type {?} */viewContainer.get(index);\n      viewRef.context.index = index;\n      viewRef.context.count = count;\n      viewRef.context.first = index === 0;\n      viewRef.context.last = index === count - 1;\n      viewRef.context.even = index % 2 === 0;\n      viewRef.context.odd = !viewRef.context.even;\n    }\n  }\n  /**\n   * Returns the cell template definitions to insert into the header\n   * as defined by its list of columns to display.\n   * @param {?} headerDef\n   * @return {?}\n   */\n  _getHeaderCellTemplatesForRow(headerDef) {\n    if (!headerDef || !headerDef.columns) {\n      return [];\n    }\n    return headerDef.columns.map(columnId => {\n      const /** @type {?} */column = this._columnDefsByName.get(columnId);\n      if (!column) {\n        throw getTableUnknownColumnError(columnId);\n      }\n      return column.headerCell;\n    });\n  }\n  /**\n   * Returns the cell template definitions to insert in the provided row\n   * as defined by its list of columns to display.\n   * @param {?} rowDef\n   * @return {?}\n   */\n  _getCellTemplatesForRow(rowDef) {\n    if (!rowDef.columns) {\n      return [];\n    }\n    return rowDef.columns.map(columnId => {\n      const /** @type {?} */column = this._columnDefsByName.get(columnId);\n      if (!column) {\n        throw getTableUnknownColumnError(columnId);\n      }\n      return column.cell;\n    });\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nconst EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkHeaderRow, CdkHeaderRowDef, RowPlaceholder, HeaderRowPlaceholder];\nclass CdkTableModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { DataSource, RowPlaceholder, HeaderRowPlaceholder, CDK_TABLE_TEMPLATE, CdkTable, CdkCellDef, CdkHeaderCellDef, CdkColumnDef, CdkHeaderCell, CdkCell, CDK_ROW_TEMPLATE, BaseRowDef, CdkHeaderRowDef, CdkRowDef, CdkCellOutlet, CdkHeaderRow, CdkRow, CdkTableModule };\n//# sourceMappingURL=table.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}