{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, Host, Inject, InjectionToken, Input, NgModule, NgZone, Optional, Output, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { MAT_OPTION_PARENT_COMPONENT, MatCommonModule, MatOptgroup, MatOption, MatOptionModule, _countGroupLabelsBeforeOption, _getOptionScrollPosition, mixinDisableRipple } from '@angular/material/core';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@angular/cdk/keycodes';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { filter } from 'rxjs/operators/filter';\nimport { take } from 'rxjs/operators/take';\nimport { switchMap } from 'rxjs/operators/switchMap';\nimport { tap } from 'rxjs/operators/tap';\nimport { delay } from 'rxjs/operators/delay';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatFormField } from '@angular/material/form-field';\nimport { Subject } from 'rxjs/Subject';\nimport { defer } from 'rxjs/observable/defer';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { merge } from 'rxjs/observable/merge';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/**\n * Event object that is emitted when an autocomplete option is selected.\n */\nclass MatAutocompleteSelectedEvent {\n  /**\n   * @param {?} source\n   * @param {?} option\n   */\n  constructor(source, option) {\n    this.source = source;\n    this.option = option;\n  }\n}\n/**\n * \\@docs-private\n */\nclass MatAutocompleteBase {}\nconst _MatAutocompleteMixinBase = mixinDisableRipple(MatAutocompleteBase);\n/**\n * Default `mat-autocomplete` options that can be overridden.\n * @record\n */\n\n/**\n * Injection token to be used to override the default options for `mat-autocomplete`.\n */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options');\nclass MatAutocomplete extends _MatAutocompleteMixinBase {\n  /**\n   * @param {?} _changeDetectorRef\n   * @param {?} _elementRef\n   * @param {?=} defaults\n   */\n  constructor(_changeDetectorRef, _elementRef,\n  // @deletion-target Turn into required param in 6.0.0\n  defaults) {\n    super();\n    this._changeDetectorRef = _changeDetectorRef;\n    this._elementRef = _elementRef;\n    /**\n     * Whether the autocomplete panel should be visible, depending on option length.\n     */\n    this.showPanel = false;\n    this._isOpen = false;\n    /**\n     * Function that maps an option's control value to its display value in the trigger.\n     */\n    this.displayWith = null;\n    /**\n     * Event that is emitted whenever an option from the list is selected.\n     */\n    this.optionSelected = new EventEmitter();\n    this._classList = {};\n    /**\n     * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n     */\n    this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n    this._autoActiveFirstOption = defaults && typeof defaults.autoActiveFirstOption !== 'undefined' ? defaults.autoActiveFirstOption : false;\n  }\n  /**\n   * Whether the autocomplete panel is open.\n   * @return {?}\n   */\n  get isOpen() {\n    return this._isOpen && this.showPanel;\n  }\n  /**\n   * Whether the first option should be highlighted when the autocomplete panel is opened.\n   * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n   * @return {?}\n   */\n  get autoActiveFirstOption() {\n    return this._autoActiveFirstOption;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set autoActiveFirstOption(value) {\n    this._autoActiveFirstOption = coerceBooleanProperty(value);\n  }\n  /**\n   * Takes classes set on the host mat-autocomplete element and applies them to the panel\n   * inside the overlay container to allow for easy styling.\n   * @param {?} value\n   * @return {?}\n   */\n  set classList(value) {\n    if (value && value.length) {\n      value.split(' ').forEach(className => this._classList[className.trim()] = true);\n      this._elementRef.nativeElement.className = '';\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\n    // Set the initial visibiity state.\n    this._setVisibility();\n  }\n  /**\n   * Sets the panel scrollTop. This allows us to manually scroll to display options\n   * above or below the fold, as they are not actually being focused when active.\n   * @param {?} scrollTop\n   * @return {?}\n   */\n  _setScrollTop(scrollTop) {\n    if (this.panel) {\n      this.panel.nativeElement.scrollTop = scrollTop;\n    }\n  }\n  /**\n   * Returns the panel's scrollTop.\n   * @return {?}\n   */\n  _getScrollTop() {\n    return this.panel ? this.panel.nativeElement.scrollTop : 0;\n  }\n  /**\n   * Panel should hide itself when the option list is empty.\n   * @return {?}\n   */\n  _setVisibility() {\n    this.showPanel = !!this.options.length;\n    this._classList['mat-autocomplete-visible'] = this.showPanel;\n    this._classList['mat-autocomplete-hidden'] = !this.showPanel;\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Emits the `select` event.\n   * @param {?} option\n   * @return {?}\n   */\n  _emitSelectEvent(option) {\n    const /** @type {?} */event = new MatAutocompleteSelectedEvent(this, option);\n    this.optionSelected.emit(event);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The height of each autocomplete option.\n */\nconst AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/**\n * The total height of the autocomplete panel.\n */\nconst AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/**\n * Injection token that determines the scroll handling while the autocomplete panel is open.\n */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/**\n * \\@docs-private\n */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * \\@docs-private\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatAutocompleteTrigger),\n  multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @return {?}\n */\nfunction getMatAutocompleteMissingPanelError() {\n  return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' + 'Make sure that the id passed to the `matAutocomplete` is correct and that ' + 'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\nclass MatAutocompleteTrigger {\n  /**\n   * @param {?} _element\n   * @param {?} _overlay\n   * @param {?} _viewContainerRef\n   * @param {?} _zone\n   * @param {?} _changeDetectorRef\n   * @param {?} _scrollStrategy\n   * @param {?} _dir\n   * @param {?} _formField\n   * @param {?} _document\n   */\n  constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _scrollStrategy, _dir, _formField, _document) {\n    this._element = _element;\n    this._overlay = _overlay;\n    this._viewContainerRef = _viewContainerRef;\n    this._zone = _zone;\n    this._changeDetectorRef = _changeDetectorRef;\n    this._scrollStrategy = _scrollStrategy;\n    this._dir = _dir;\n    this._formField = _formField;\n    this._document = _document;\n    this._componentDestroyed = false;\n    /**\n     * Whether or not the label state is being overridden.\n     */\n    this._manuallyFloatingLabel = false;\n    /**\n     * Stream of keyboard events that can close the panel.\n     */\n    this._closeKeyEventStream = new Subject();\n    /**\n     * `View -> model callback called when value changes`\n     */\n    this._onChange = () => {};\n    /**\n     * `View -> model callback called when autocomplete has been touched`\n     */\n    this._onTouched = () => {};\n    this._panelOpen = false;\n    /**\n     * Stream of autocomplete option selections.\n     */\n    this.optionSelections = defer(() => {\n      if (this.autocomplete && this.autocomplete.options) {\n        return merge(...this.autocomplete.options.map(option => option.onSelectionChange));\n      }\n      // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n      // Return a stream that we'll replace with the real one once everything is in place.\n      return this._zone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionSelections));\n    });\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._componentDestroyed = true;\n    this._destroyPanel();\n    this._closeKeyEventStream.complete();\n  }\n  /**\n   * Whether or not the autocomplete panel is open.\n   * @return {?}\n   */\n  get panelOpen() {\n    return this._panelOpen && this.autocomplete.showPanel;\n  }\n  /**\n   * Opens the autocomplete suggestion panel.\n   * @return {?}\n   */\n  openPanel() {\n    this._attachOverlay();\n    this._floatLabel();\n  }\n  /**\n   * Closes the autocomplete suggestion panel.\n   * @return {?}\n   */\n  closePanel() {\n    this._resetLabel();\n    if (this._panelOpen) {\n      this.autocomplete._isOpen = this._panelOpen = false;\n      if (this._overlayRef && this._overlayRef.hasAttached()) {\n        this._overlayRef.detach();\n        this._closingActionsSubscription.unsubscribe();\n      }\n      // Note that in some cases this can end up being called after the component is destroyed.\n      // Add a check to ensure that we don't try to run change detection on a destroyed view.\n      if (!this._componentDestroyed) {\n        // We need to trigger change detection manually, because\n        // `fromEvent` doesn't seem to do it at the proper time.\n        // This ensures that the label is reset when the\n        // user clicks outside.\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n  }\n  /**\n   * A stream of actions that should close the autocomplete panel, including\n   * when an option is selected, on blur, and when TAB is pressed.\n   * @return {?}\n   */\n  get panelClosingActions() {\n    return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._panelOpen)), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ? this._overlayRef.detachments().pipe(filter(() => this._panelOpen)) : of());\n  }\n  /**\n   * The currently active option, coerced to MatOption type.\n   * @return {?}\n   */\n  get activeOption() {\n    if (this.autocomplete && this.autocomplete._keyManager) {\n      return this.autocomplete._keyManager.activeItem;\n    }\n    return null;\n  }\n  /**\n   * Stream of clicks outside of the autocomplete panel.\n   * @return {?}\n   */\n  get _outsideClickStream() {\n    if (!this._document) {\n      return of(null);\n    }\n    return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'touchend')).pipe(filter(event => {\n      const /** @type {?} */clickTarget = /** @type {?} */event.target;\n      const /** @type {?} */formField = this._formField ? this._formField._elementRef.nativeElement : null;\n      return this._panelOpen && clickTarget !== this._element.nativeElement && (!formField || !formField.contains(clickTarget)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget);\n    }));\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    Promise.resolve(null).then(() => this._setTriggerValue(value));\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this._onChange = fn;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this._onTouched = fn;\n  }\n  /**\n   * @param {?} isDisabled\n   * @return {?}\n   */\n  setDisabledState(isDisabled) {\n    this._element.nativeElement.disabled = isDisabled;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _handleKeydown(event) {\n    const /** @type {?} */keyCode = event.keyCode;\n    // Prevent the default action on all escape key presses. This is here primarily to bring IE\n    // in line with other browsers. By default, pressing escape on IE will cause it to revert\n    // the input value to the one that it had on focus, however it won't dispatch any events\n    // which means that the model value will be out of sync with the view.\n    if (keyCode === ESCAPE) {\n      event.preventDefault();\n    }\n    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n    if (this.panelOpen && (keyCode === ESCAPE || keyCode === UP_ARROW && event.altKey)) {\n      this._resetActiveItem();\n      this._closeKeyEventStream.next();\n      event.stopPropagation();\n    } else if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n      this.activeOption._selectViaInteraction();\n      this._resetActiveItem();\n      event.preventDefault();\n    } else {\n      const /** @type {?} */prevActiveItem = this.autocomplete._keyManager.activeItem;\n      const /** @type {?} */isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n      if (this.panelOpen || keyCode === TAB) {\n        this.autocomplete._keyManager.onKeydown(event);\n      } else if (isArrowKey && this._canOpen()) {\n        this.openPanel();\n      }\n      if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n        this._scrollToOption();\n      }\n    }\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _handleInput(event) {\n    let /** @type {?} */target = /** @type {?} */event.target;\n    let /** @type {?} */value = target.value;\n    // Based on `NumberValueAccessor` from forms.\n    if (target.type === 'number') {\n      value = value == '' ? null : parseFloat(value);\n    }\n    // If the input has a placeholder, IE will fire the `input` event on page load,\n    // focus and blur, in addition to when the user actually changed the value. To\n    // filter out all of the extra events, we save the value on focus and between\n    // `input` events, and we check whether it changed.\n    // See: https://connect.microsoft.com/IE/feedback/details/885747/\n    if (this._canOpen() && this._previousValue !== value && document.activeElement === event.target) {\n      this._previousValue = value;\n      this._onChange(value);\n      this.openPanel();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _handleFocus() {\n    if (this._canOpen()) {\n      this._previousValue = this._element.nativeElement.value;\n      this._attachOverlay();\n      this._floatLabel(true);\n    }\n  }\n  /**\n   * In \"auto\" mode, the label will animate down as soon as focus is lost.\n   * This causes the value to jump when selecting an option with the mouse.\n   * This method manually floats the label until the panel can be closed.\n   * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\n   * @return {?}\n   */\n  _floatLabel(shouldAnimate = false) {\n    if (this._formField && this._formField.floatLabel === 'auto') {\n      if (shouldAnimate) {\n        this._formField._animateAndLockLabel();\n      } else {\n        this._formField.floatLabel = 'always';\n      }\n      this._manuallyFloatingLabel = true;\n    }\n  }\n  /**\n   * If the label has been manually elevated, return it to its normal state.\n   * @return {?}\n   */\n  _resetLabel() {\n    if (this._manuallyFloatingLabel) {\n      this._formField.floatLabel = 'auto';\n      this._manuallyFloatingLabel = false;\n    }\n  }\n  /**\n   * Given that we are not actually focusing active options, we must manually adjust scroll\n   * to reveal options below the fold. First, we find the offset of the option from the top\n   * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n   * the panel height + the option height, so the active option will be just visible at the\n   * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n   * will become the offset. If that offset is visible within the panel already, the scrollTop is\n   * not adjusted.\n   * @return {?}\n   */\n  _scrollToOption() {\n    const /** @type {?} */index = this.autocomplete._keyManager.activeItemIndex || 0;\n    const /** @type {?} */labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n    const /** @type {?} */newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n    this.autocomplete._setScrollTop(newScrollPosition);\n  }\n  /**\n   * This method listens to a stream of panel closing actions and resets the\n   * stream every time the option list changes.\n   * @return {?}\n   */\n  _subscribeToClosingActions() {\n    const /** @type {?} */firstStable = this._zone.onStable.asObservable().pipe(take(1));\n    const /** @type {?} */optionChanges = this.autocomplete.options.changes.pipe(tap(() => this._positionStrategy.recalculateLastPosition()),\n    // Defer emitting to the stream until the next tick, because changing\n    // bindings in here will cause \"changed after checked\" errors.\n    delay(0));\n    // When the zone is stable initially, and when the option list changes...\n    return merge(firstStable, optionChanges).pipe(\n    // create a new stream of panelClosingActions, replacing any previous streams\n    // that were created, and flatten it so our stream only emits closing events...\n    switchMap(() => {\n      this._resetActiveItem();\n      this.autocomplete._setVisibility();\n      return this.panelClosingActions;\n    }),\n    // when the first closing event occurs...\n    take(1)).subscribe(event => this._setValueAndClose(event));\n  }\n  /**\n   * Destroys the autocomplete suggestion panel.\n   * @return {?}\n   */\n  _destroyPanel() {\n    if (this._overlayRef) {\n      this.closePanel();\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  _setTriggerValue(value) {\n    const /** @type {?} */toDisplay = this.autocomplete && this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value;\n    // Simply falling back to an empty string if the display value is falsy does not work properly.\n    // The display value can also be the number zero and shouldn't fall back to an empty string.\n    const /** @type {?} */inputValue = toDisplay != null ? toDisplay : '';\n    // If it's used within a `MatFormField`, we should set it through the property so it can go\n    // through change detection.\n    if (this._formField) {\n      this._formField._control.value = inputValue;\n    } else {\n      this._element.nativeElement.value = inputValue;\n    }\n  }\n  /**\n   * This method closes the panel, and if a value is specified, also sets the associated\n   * control to that value. It will also mark the control as dirty if this interaction\n   * stemmed from the user.\n   * @param {?} event\n   * @return {?}\n   */\n  _setValueAndClose(event) {\n    if (event && event.source) {\n      this._clearPreviousSelectedOption(event.source);\n      this._setTriggerValue(event.source.value);\n      this._onChange(event.source.value);\n      this._element.nativeElement.focus();\n      this.autocomplete._emitSelectEvent(event.source);\n    }\n    this.closePanel();\n  }\n  /**\n   * Clear any previous selected option and emit a selection change event for this option\n   * @param {?} skip\n   * @return {?}\n   */\n  _clearPreviousSelectedOption(skip) {\n    this.autocomplete.options.forEach(option => {\n      if (option != skip && option.selected) {\n        option.deselect();\n      }\n    });\n  }\n  /**\n   * @return {?}\n   */\n  _attachOverlay() {\n    if (!this.autocomplete) {\n      throw getMatAutocompleteMissingPanelError();\n    }\n    if (!this._overlayRef) {\n      this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n      this._overlayRef = this._overlay.create(this._getOverlayConfig());\n    } else {\n      /** Update the panel width, in case the host width has changed */\n      this._overlayRef.updateSize({\n        width: this._getHostWidth()\n      });\n    }\n    if (this._overlayRef && !this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._portal);\n      this._closingActionsSubscription = this._subscribeToClosingActions();\n    }\n    this.autocomplete._setVisibility();\n    this.autocomplete._isOpen = this._panelOpen = true;\n  }\n  /**\n   * @return {?}\n   */\n  _getOverlayConfig() {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPosition(),\n      scrollStrategy: this._scrollStrategy(),\n      width: this._getHostWidth(),\n      direction: this._dir ? this._dir.value : 'ltr'\n    });\n  }\n  /**\n   * @return {?}\n   */\n  _getOverlayPosition() {\n    this._positionStrategy = this._overlay.position().connectedTo(this._getConnectedElement(), {\n      originX: 'start',\n      originY: 'bottom'\n    }, {\n      overlayX: 'start',\n      overlayY: 'top'\n    }).withFallbackPosition({\n      originX: 'start',\n      originY: 'top'\n    }, {\n      overlayX: 'start',\n      overlayY: 'bottom'\n    });\n    return this._positionStrategy;\n  }\n  /**\n   * @return {?}\n   */\n  _getConnectedElement() {\n    return this._formField ? this._formField._connectionContainerRef : this._element;\n  }\n  /**\n   * Returns the width of the input element, so the panel width can match it.\n   * @return {?}\n   */\n  _getHostWidth() {\n    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n  }\n  /**\n   * Resets the active item to -1 so arrow events will activate the\n   * correct options, or to 0 if the consumer opted into it.\n   * @return {?}\n   */\n  _resetActiveItem() {\n    this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n  }\n  /**\n   * Determines whether the panel can be opened.\n   * @return {?}\n   */\n  _canOpen() {\n    const /** @type {?} */element = this._element.nativeElement;\n    return !element.readOnly && !element.disabled;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatAutocompleteModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatAutocompleteSelectedEvent, MatAutocompleteBase, _MatAutocompleteMixinBase, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, getMatAutocompleteMissingPanelError, MatAutocompleteTrigger };\n//# sourceMappingURL=autocomplete.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}