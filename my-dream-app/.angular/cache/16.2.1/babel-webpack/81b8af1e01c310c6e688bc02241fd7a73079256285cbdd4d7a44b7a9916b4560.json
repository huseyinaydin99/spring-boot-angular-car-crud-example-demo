{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { A11yModule, ARIA_DESCRIBER_PROVIDER, AriaDescriber, FocusMonitor } from '@angular/cdk/a11y';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Inject, InjectionToken, Input, NgModule, NgZone, Optional, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nimport { BreakpointObserver, Breakpoints, LayoutModule } from '@angular/cdk/layout';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { take } from 'rxjs/operators/take';\nimport { merge } from 'rxjs/observable/merge';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { Subject } from 'rxjs/Subject';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by MatTooltip.\n */\nconst matTooltipAnimations = {\n  /** Animation that transitions a tooltip in and out. */\n  tooltipState: trigger('state', [state('initial, void, hidden', style({\n    transform: 'scale(0)'\n  })), state('visible', style({\n    transform: 'scale(1)'\n  })), transition('* => visible', animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')), transition('* => hidden', animate('150ms cubic-bezier(0.4, 0.0, 1, 1)'))])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Time in ms to throttle repositioning after scroll events.\n */\nconst SCROLL_THROTTLE_MS = 20;\n/**\n * CSS class that will be attached to the overlay panel.\n */\nconst TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @param {?} position\n * @return {?}\n */\nfunction getMatTooltipInvalidPositionError(position) {\n  return Error(`Tooltip position \"${position}\" is invalid.`);\n}\n/**\n * Injection token that determines the scroll handling while a tooltip is visible.\n */\nconst MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken('mat-tooltip-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition({\n    scrollThrottle: SCROLL_THROTTLE_MS\n  });\n}\n/**\n * \\@docs-private\n */\nconst MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Default `matTooltip` options that can be overridden.\n * @record\n */\n\n/**\n * Injection token to be used to override the default options for `matTooltip`.\n */\nconst MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken('mat-tooltip-default-options');\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.google.com/components/tooltips.html\n */\nclass MatTooltip {\n  /**\n   * @param {?} _overlay\n   * @param {?} _elementRef\n   * @param {?} _scrollDispatcher\n   * @param {?} _viewContainerRef\n   * @param {?} _ngZone\n   * @param {?} _platform\n   * @param {?} _ariaDescriber\n   * @param {?} _focusMonitor\n   * @param {?} _scrollStrategy\n   * @param {?} _dir\n   * @param {?=} _defaultOptions\n   */\n  constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions) {\n    // TODO(crisbeto): make the `_defaultOptions` a required param next time we do breaking changes.\n    // @deletion-target 6.0.0\n    this._overlay = _overlay;\n    this._elementRef = _elementRef;\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewContainerRef = _viewContainerRef;\n    this._ngZone = _ngZone;\n    this._platform = _platform;\n    this._ariaDescriber = _ariaDescriber;\n    this._focusMonitor = _focusMonitor;\n    this._scrollStrategy = _scrollStrategy;\n    this._dir = _dir;\n    this._defaultOptions = _defaultOptions;\n    this._position = 'below';\n    this._disabled = false;\n    /**\n     * The default delay in ms before showing the tooltip after show is called\n     */\n    this.showDelay = this._defaultOptions ? this._defaultOptions.showDelay : 0;\n    /**\n     * The default delay in ms before hiding the tooltip after hide is called\n     */\n    this.hideDelay = this._defaultOptions ? this._defaultOptions.hideDelay : 0;\n    this._message = '';\n    this._manualListeners = new Map();\n    const /** @type {?} */element = _elementRef.nativeElement;\n    // The mouse events shouldn't be bound on iOS devices, because\n    // they can prevent the first tap from firing its click event.\n    if (!_platform.IOS) {\n      this._manualListeners.set('mouseenter', () => this.show());\n      this._manualListeners.set('mouseleave', () => this.hide());\n      this._manualListeners.forEach((listener, event) => _elementRef.nativeElement.addEventListener(event, listener));\n    } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n      // When we bind a gesture event on an element (in this case `longpress`), HammerJS\n      // will add some inline styles by default, including `user-select: none`. This is\n      // problematic on iOS, because it will prevent users from typing in inputs. If\n      // we're on iOS and the tooltip is attached on an input or textarea, we clear\n      // the `user-select` to avoid these issues.\n      element.style.webkitUserSelect = element.style.userSelect = '';\n    }\n    _focusMonitor.monitor(element).subscribe(origin => {\n      // Note that the focus monitor runs outside the Angular zone.\n      if (!origin) {\n        _ngZone.run(() => this.hide(0));\n      } else if (origin !== 'program') {\n        _ngZone.run(() => this.show());\n      }\n    });\n  }\n  /**\n   * Allows the user to define the position of the tooltip relative to the parent element\n   * @return {?}\n   */\n  get position() {\n    return this._position;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set position(value) {\n    if (value !== this._position) {\n      this._position = value;\n      // TODO(andrewjs): When the overlay's position can be dynamically changed, do not destroy\n      // the tooltip.\n      if (this._tooltipInstance) {\n        this._disposeTooltip();\n      }\n    }\n  }\n  /**\n   * Disables the display of the tooltip.\n   * @return {?}\n   */\n  get disabled() {\n    return this._disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n    // If tooltip is disabled, hide immediately.\n    if (this._disabled) {\n      this.hide(0);\n    }\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _positionDeprecated() {\n    return this._position;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set _positionDeprecated(value) {\n    this._position = value;\n  }\n  /**\n   * The message to be displayed in the tooltip\n   * @return {?}\n   */\n  get message() {\n    return this._message;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set message(value) {\n    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\n    // If the message is not a string (e.g. number), convert it to a string and trim it.\n    this._message = value != null ? `${value}`.trim() : '';\n    if (!this._message && this._isTooltipVisible()) {\n      this.hide(0);\n    } else {\n      this._updateTooltipMessage();\n      this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);\n    }\n  }\n  /**\n   * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.\n   * @return {?}\n   */\n  get tooltipClass() {\n    return this._tooltipClass;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set tooltipClass(value) {\n    this._tooltipClass = value;\n    if (this._tooltipInstance) {\n      this._setTooltipClass(this._tooltipClass);\n    }\n  }\n  /**\n   * Dispose the tooltip when destroyed.\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this._tooltipInstance) {\n      this._disposeTooltip();\n    }\n    // Clean up the event listeners set in the constructor\n    if (!this._platform.IOS) {\n      this._manualListeners.forEach((listener, event) => {\n        this._elementRef.nativeElement.removeEventListener(event, listener);\n      });\n      this._manualListeners.clear();\n    }\n    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);\n    this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n  }\n  /**\n   * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\n   * @param {?=} delay\n   * @return {?}\n   */\n  show(delay = this.showDelay) {\n    if (this.disabled || !this.message) {\n      return;\n    }\n    if (!this._tooltipInstance) {\n      this._createTooltip();\n    }\n    this._setTooltipClass(this._tooltipClass);\n    this._updateTooltipMessage(); /** @type {?} */\n    this._tooltipInstance.show(this._position, delay);\n  }\n  /**\n   * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\n   * @param {?=} delay\n   * @return {?}\n   */\n  hide(delay = this.hideDelay) {\n    if (this._tooltipInstance) {\n      this._tooltipInstance.hide(delay);\n    }\n  }\n  /**\n   * Shows/hides the tooltip\n   * @return {?}\n   */\n  toggle() {\n    this._isTooltipVisible() ? this.hide() : this.show();\n  }\n  /**\n   * Returns true if the tooltip is currently visible to the user\n   * @return {?}\n   */\n  _isTooltipVisible() {\n    return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n  }\n  /**\n   * Handles the keydown events on the host element.\n   * @param {?} e\n   * @return {?}\n   */\n  _handleKeydown(e) {\n    if (this._isTooltipVisible() && e.keyCode === ESCAPE) {\n      e.stopPropagation();\n      this.hide(0);\n    }\n  }\n  /**\n   * Handles the touchend events on the host element.\n   * @return {?}\n   */\n  _handleTouchend() {\n    this.hide(this._defaultOptions ? this._defaultOptions.touchendHideDelay : 1500);\n  }\n  /**\n   * Create the tooltip to display\n   * @return {?}\n   */\n  _createTooltip() {\n    const /** @type {?} */overlayRef = this._createOverlay();\n    const /** @type {?} */portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);\n    this._tooltipInstance = overlayRef.attach(portal).instance;\n    // Dispose of the tooltip when the overlay is detached.\n    merge( /** @type {?} */this._tooltipInstance.afterHidden(), overlayRef.detachments()).subscribe(() => {\n      // Check first if the tooltip has already been removed through this components destroy.\n      if (this._tooltipInstance) {\n        this._disposeTooltip();\n      }\n    });\n  }\n  /**\n   * Create the overlay config and position strategy\n   * @return {?}\n   */\n  _createOverlay() {\n    const /** @type {?} */origin = this._getOrigin();\n    const /** @type {?} */overlay = this._getOverlayPosition();\n    // Create connected position strategy that listens for scroll events to reposition.\n    const /** @type {?} */strategy = this._overlay.position().connectedTo(this._elementRef, origin.main, overlay.main).withFallbackPosition(origin.fallback, overlay.fallback);\n    const /** @type {?} */scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);\n    strategy.withScrollableContainers(scrollableAncestors);\n    strategy.onPositionChange.subscribe(change => {\n      if (this._tooltipInstance) {\n        if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {\n          // After position changes occur and the overlay is clipped by\n          // a parent scrollable then close the tooltip.\n          this._ngZone.run(() => this.hide(0));\n        } else {\n          // Otherwise recalculate the origin based on the new position.\n          this._tooltipInstance._setTransformOrigin(change.connectionPair);\n        }\n      }\n    });\n    const /** @type {?} */config = new OverlayConfig({\n      direction: this._dir ? this._dir.value : 'ltr',\n      positionStrategy: strategy,\n      panelClass: TOOLTIP_PANEL_CLASS,\n      scrollStrategy: this._scrollStrategy()\n    });\n    this._overlayRef = this._overlay.create(config);\n    return this._overlayRef;\n  }\n  /**\n   * Disposes the current tooltip and the overlay it is attached to\n   * @return {?}\n   */\n  _disposeTooltip() {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n    this._tooltipInstance = null;\n  }\n  /**\n   * Returns the origin position and a fallback position based on the user's position preference.\n   * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n   * @return {?}\n   */\n  _getOrigin() {\n    const /** @type {?} */isDirectionLtr = !this._dir || this._dir.value == 'ltr';\n    let /** @type {?} */position;\n    if (this.position == 'above' || this.position == 'below') {\n      position = {\n        originX: 'center',\n        originY: this.position == 'above' ? 'top' : 'bottom'\n      };\n    } else if (this.position == 'left' || this.position == 'before' && isDirectionLtr || this.position == 'after' && !isDirectionLtr) {\n      position = {\n        originX: 'start',\n        originY: 'center'\n      };\n    } else if (this.position == 'right' || this.position == 'after' && isDirectionLtr || this.position == 'before' && !isDirectionLtr) {\n      position = {\n        originX: 'end',\n        originY: 'center'\n      };\n    } else {\n      throw getMatTooltipInvalidPositionError(this.position);\n    }\n    const {\n      x,\n      y\n    } = this._invertPosition(position.originX, position.originY);\n    return {\n      main: position,\n      fallback: {\n        originX: x,\n        originY: y\n      }\n    };\n  }\n  /**\n   * Returns the overlay position and a fallback position based on the user's preference\n   * @return {?}\n   */\n  _getOverlayPosition() {\n    const /** @type {?} */isLtr = !this._dir || this._dir.value == 'ltr';\n    let /** @type {?} */position;\n    if (this.position == 'above') {\n      position = {\n        overlayX: 'center',\n        overlayY: 'bottom'\n      };\n    } else if (this.position == 'below') {\n      position = {\n        overlayX: 'center',\n        overlayY: 'top'\n      };\n    } else if (this.position == 'left' || this.position == 'before' && isLtr || this.position == 'after' && !isLtr) {\n      position = {\n        overlayX: 'end',\n        overlayY: 'center'\n      };\n    } else if (this.position == 'right' || this.position == 'after' && isLtr || this.position == 'before' && !isLtr) {\n      position = {\n        overlayX: 'start',\n        overlayY: 'center'\n      };\n    } else {\n      throw getMatTooltipInvalidPositionError(this.position);\n    }\n    const {\n      x,\n      y\n    } = this._invertPosition(position.overlayX, position.overlayY);\n    return {\n      main: position,\n      fallback: {\n        overlayX: x,\n        overlayY: y\n      }\n    };\n  }\n  /**\n   * Updates the tooltip message and repositions the overlay according to the new message length\n   * @return {?}\n   */\n  _updateTooltipMessage() {\n    // Must wait for the message to be painted to the tooltip so that the overlay can properly\n    // calculate the correct positioning based on the size of the text.\n    if (this._tooltipInstance) {\n      this._tooltipInstance.message = this.message;\n      this._tooltipInstance._markForCheck();\n      this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(() => {\n        if (this._tooltipInstance) {\n          /** @type {?} */this._overlayRef.updatePosition();\n        }\n      });\n    }\n  }\n  /**\n   * Updates the tooltip class\n   * @param {?} tooltipClass\n   * @return {?}\n   */\n  _setTooltipClass(tooltipClass) {\n    if (this._tooltipInstance) {\n      this._tooltipInstance.tooltipClass = tooltipClass;\n      this._tooltipInstance._markForCheck();\n    }\n  }\n  /**\n   * Inverts an overlay position.\n   * @param {?} x\n   * @param {?} y\n   * @return {?}\n   */\n  _invertPosition(x, y) {\n    if (this.position === 'above' || this.position === 'below') {\n      if (y === 'top') {\n        y = 'bottom';\n      } else if (y === 'bottom') {\n        y = 'top';\n      }\n    } else {\n      if (x === 'end') {\n        x = 'start';\n      } else if (x === 'start') {\n        x = 'end';\n      }\n    }\n    return {\n      x,\n      y\n    };\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Internal component that wraps the tooltip's content.\n * \\@docs-private\n */\nclass TooltipComponent {\n  /**\n   * @param {?} _changeDetectorRef\n   * @param {?} _breakpointObserver\n   */\n  constructor(_changeDetectorRef, _breakpointObserver) {\n    this._changeDetectorRef = _changeDetectorRef;\n    this._breakpointObserver = _breakpointObserver;\n    /**\n     * Property watched by the animation framework to show or hide the tooltip\n     */\n    this._visibility = 'initial';\n    /**\n     * Whether interactions on the page should close the tooltip\n     */\n    this._closeOnInteraction = false;\n    /**\n     * The transform origin used in the animation for showing and hiding the tooltip\n     */\n    this._transformOrigin = 'bottom';\n    /**\n     * Subject for notifying that the tooltip has been hidden from the view\n     */\n    this._onHide = new Subject();\n    /**\n     * Stream that emits whether the user has a handset-sized display.\n     */\n    this._isHandset = this._breakpointObserver.observe(Breakpoints.Handset);\n  }\n  /**\n   * Shows the tooltip with an animation originating from the provided origin\n   * @param {?} position Position of the tooltip.\n   * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\n   * @return {?}\n   */\n  show(position, delay) {\n    // Cancel the delayed hide if it is scheduled\n    if (this._hideTimeoutId) {\n      clearTimeout(this._hideTimeoutId);\n    }\n    // Body interactions should cancel the tooltip if there is a delay in showing.\n    this._closeOnInteraction = true;\n    this._position = position;\n    this._showTimeoutId = setTimeout(() => {\n      this._visibility = 'visible';\n      // Mark for check so if any parent component has set the\n      // ChangeDetectionStrategy to OnPush it will be checked anyways\n      this._markForCheck();\n    }, delay);\n  }\n  /**\n   * Begins the animation to hide the tooltip after the provided delay in ms.\n   * @param {?} delay Amount of milliseconds to delay showing the tooltip.\n   * @return {?}\n   */\n  hide(delay) {\n    // Cancel the delayed show if it is scheduled\n    if (this._showTimeoutId) {\n      clearTimeout(this._showTimeoutId);\n    }\n    this._hideTimeoutId = setTimeout(() => {\n      this._visibility = 'hidden';\n      // Mark for check so if any parent component has set the\n      // ChangeDetectionStrategy to OnPush it will be checked anyways\n      this._markForCheck();\n    }, delay);\n  }\n  /**\n   * Returns an observable that notifies when the tooltip has been hidden from view.\n   * @return {?}\n   */\n  afterHidden() {\n    return this._onHide.asObservable();\n  }\n  /**\n   * Whether the tooltip is being displayed.\n   * @return {?}\n   */\n  isVisible() {\n    return this._visibility === 'visible';\n  }\n  /**\n   * Sets the tooltip transform origin according to the position of the tooltip overlay.\n   * @param {?} overlayPosition\n   * @return {?}\n   */\n  _setTransformOrigin(overlayPosition) {\n    const /** @type {?} */axis = this._position === 'above' || this._position === 'below' ? 'Y' : 'X';\n    const /** @type {?} */position = axis == 'X' ? overlayPosition.overlayX : overlayPosition.overlayY;\n    if (position === 'top' || position === 'bottom') {\n      this._transformOrigin = position;\n    } else if (position === 'start') {\n      this._transformOrigin = 'left';\n    } else if (position === 'end') {\n      this._transformOrigin = 'right';\n    } else {\n      throw getMatTooltipInvalidPositionError(this._position);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _animationStart() {\n    this._closeOnInteraction = false;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _animationDone(event) {\n    const /** @type {?} */toState = /** @type {?} */event.toState;\n    if (toState === 'hidden' && !this.isVisible()) {\n      this._onHide.next();\n    }\n    if (toState === 'visible' || toState === 'hidden') {\n      this._closeOnInteraction = true;\n    }\n  }\n  /**\n   * Interactions on the HTML body should close the tooltip immediately as defined in the\n   * material design spec.\n   * https://material.google.com/components/tooltips.html#tooltips-interaction\n   * @return {?}\n   */\n  _handleBodyInteraction() {\n    if (this._closeOnInteraction) {\n      this.hide(0);\n    }\n  }\n  /**\n   * Marks that the tooltip needs to be checked in the next change detection run.\n   * Mainly used for rendering the initial text before positioning a tooltip, which\n   * can be problematic in components with OnPush change detection.\n   * @return {?}\n   */\n  _markForCheck() {\n    this._changeDetectorRef.markForCheck();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nconst ɵ0 = {\n  showDelay: 0,\n  hideDelay: 0,\n  touchendHideDelay: 1500\n};\nclass MatTooltipModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatTooltipModule, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations };\n//# sourceMappingURL=tooltip.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}