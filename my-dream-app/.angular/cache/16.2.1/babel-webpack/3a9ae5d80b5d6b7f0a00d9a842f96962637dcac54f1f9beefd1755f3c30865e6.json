{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, Inject, Input, NgModule, Optional, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { MAT_LABEL_GLOBAL_OPTIONS, mixinColor } from '@angular/material/core';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { startWith } from 'rxjs/operators/startWith';\nimport { take } from 'rxjs/operators/take';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nlet nextUniqueId = 0;\n/**\n * Single error message to be shown underneath the form field.\n */\nclass MatError {\n  constructor() {\n    this.id = `mat-error-${nextUniqueId++}`;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the MatFormField.\n */\nconst matFormFieldAnimations = {\n  /** Animation that transitions the form field's error and hint messages. */\n  transitionMessages: trigger('transitionMessages', [\n  // TODO(mmalerba): Use angular animations for label animation as well.\n  state('enter', style({\n    opacity: 1,\n    transform: 'translateY(0%)'\n  })), transition('void => enter', [style({\n    opacity: 0,\n    transform: 'translateY(-100%)'\n  }), animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')])])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * An interface which allows a control to work inside of a `MatFormField`.\n * @abstract\n * @template T\n */\nclass MatFormFieldControl {}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getMatFormFieldPlaceholderConflictError() {\n  return Error('Placeholder attribute and child element were both specified.');\n}\n/**\n * \\@docs-private\n * @param {?} align\n * @return {?}\n */\nfunction getMatFormFieldDuplicatedHintError(align) {\n  return Error(`A hint was already declared for 'align=\"${align}\"'.`);\n}\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getMatFormFieldMissingControlError() {\n  return Error('mat-form-field must contain a MatFormFieldControl.');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nlet nextUniqueId$2 = 0;\n/**\n * Hint text to be shown underneath the form field control.\n */\nclass MatHint {\n  constructor() {\n    /**\n     * Whether to align the hint label at the start or end of the line.\n     */\n    this.align = 'start';\n    /**\n     * Unique ID for the hint. Used for the aria-describedby on the form field control.\n     */\n    this.id = `mat-hint-${nextUniqueId$2++}`;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The floating label for a `mat-form-field`.\n */\nclass MatLabel {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The placeholder text for an `MatFormField`.\n */\nclass MatPlaceholder {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Prefix to be placed the the front of the form field.\n */\nclass MatPrefix {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Suffix to be placed at the end of the form field.\n */\nclass MatSuffix {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatFormFieldBase {\n  /**\n   * @param {?} _elementRef\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n}\nconst _MatFormFieldMixinBase = mixinColor(MatFormFieldBase, 'primary');\nlet nextUniqueId$1 = 0;\n/**\n * Container for form controls that applies Material Design styling and behavior.\n */\nclass MatFormField extends _MatFormFieldMixinBase {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _changeDetectorRef\n   * @param {?} labelOptions\n   */\n  constructor(_elementRef, _changeDetectorRef, labelOptions) {\n    super(_elementRef);\n    this._elementRef = _elementRef;\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * Override for the logic that disables the label animation in certain cases.\n     */\n    this._showAlwaysAnimate = false;\n    /**\n     * State of the mat-hint and mat-error animations.\n     */\n    this._subscriptAnimationState = '';\n    this._hintLabel = '';\n    // Unique id for the hint label.\n    this._hintLabelId = `mat-hint-${nextUniqueId$1++}`;\n    this._labelOptions = labelOptions ? labelOptions : {};\n    this.floatLabel = this._labelOptions.float || 'auto';\n  }\n  /**\n   * @deprecated Use `color` instead.\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get dividerColor() {\n    return this.color;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set dividerColor(value) {\n    this.color = value;\n  }\n  /**\n   * Whether the required marker should be hidden.\n   * @return {?}\n   */\n  get hideRequiredMarker() {\n    return this._hideRequiredMarker;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set hideRequiredMarker(value) {\n    this._hideRequiredMarker = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether the floating label should always float or not.\n   * @return {?}\n   */\n  get _shouldAlwaysFloat() {\n    return this._floatLabel === 'always' && !this._showAlwaysAnimate;\n  }\n  /**\n   * Whether the label can float or not.\n   * @return {?}\n   */\n  get _canLabelFloat() {\n    return this._floatLabel !== 'never';\n  }\n  /**\n   * Text for the form field hint.\n   * @return {?}\n   */\n  get hintLabel() {\n    return this._hintLabel;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set hintLabel(value) {\n    this._hintLabel = value;\n    this._processHints();\n  }\n  /**\n   * Whether the placeholder should always float, never float or float as the user types.\n   * @deprecated Use floatLabel instead.\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get floatPlaceholder() {\n    return this._floatLabel;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set floatPlaceholder(value) {\n    this.floatLabel = value;\n  }\n  /**\n   * Whether the label should always float, never float or float as the user types.\n   * @return {?}\n   */\n  get floatLabel() {\n    return this._floatLabel;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set floatLabel(value) {\n    if (value !== this._floatLabel) {\n      this._floatLabel = value || this._labelOptions.float || 'auto';\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this._validateControlChild();\n    if (this._control.controlType) {\n      this._elementRef.nativeElement.classList.add(`mat-form-field-type-${this._control.controlType}`);\n    }\n    // Subscribe to changes in the child control state in order to update the form field UI.\n    this._control.stateChanges.pipe(startWith( /** @type {?} */null)).subscribe(() => {\n      this._validatePlaceholders();\n      this._syncDescribedByIds();\n      this._changeDetectorRef.markForCheck();\n    });\n    let /** @type {?} */ngControl = this._control.ngControl;\n    if (ngControl && ngControl.valueChanges) {\n      ngControl.valueChanges.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n    // Re-validate when the number of hints changes.\n    this._hintChildren.changes.pipe(startWith(null)).subscribe(() => {\n      this._processHints();\n      this._changeDetectorRef.markForCheck();\n    });\n    // Update the aria-described by when the number of errors changes.\n    this._errorChildren.changes.pipe(startWith(null)).subscribe(() => {\n      this._syncDescribedByIds();\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterContentChecked() {\n    this._validateControlChild();\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterViewInit() {\n    // Avoid animations on load.\n    this._subscriptAnimationState = 'enter';\n    this._changeDetectorRef.detectChanges();\n  }\n  /**\n   * Determines whether a class from the NgControl should be forwarded to the host element.\n   * @param {?} prop\n   * @return {?}\n   */\n  _shouldForward(prop) {\n    let /** @type {?} */ngControl = this._control ? this._control.ngControl : null;\n    return ngControl && /** @type {?} */ngControl[prop];\n  }\n  /**\n   * @return {?}\n   */\n  _hasPlaceholder() {\n    return !!(this._control.placeholder || this._placeholderChild);\n  }\n  /**\n   * @return {?}\n   */\n  _hasLabel() {\n    return !!this._labelChild;\n  }\n  /**\n   * @return {?}\n   */\n  _shouldLabelFloat() {\n    return this._canLabelFloat && (this._control.shouldLabelFloat || this._control.shouldPlaceholderFloat || this._shouldAlwaysFloat);\n  }\n  /**\n   * @return {?}\n   */\n  _hideControlPlaceholder() {\n    return !this._hasLabel() || !this._shouldLabelFloat();\n  }\n  /**\n   * @return {?}\n   */\n  _hasFloatingLabel() {\n    return this._hasLabel() || this._hasPlaceholder();\n  }\n  /**\n   * Determines whether to display hints or errors.\n   * @return {?}\n   */\n  _getDisplayedMessages() {\n    return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? 'error' : 'hint';\n  }\n  /**\n   * Animates the placeholder up and locks it in position.\n   * @return {?}\n   */\n  _animateAndLockLabel() {\n    if (this._hasFloatingLabel() && this._canLabelFloat) {\n      this._showAlwaysAnimate = true;\n      this._floatLabel = 'always';\n      fromEvent(this._label.nativeElement, 'transitionend').pipe(take(1)).subscribe(() => {\n        this._showAlwaysAnimate = false;\n      });\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n   * or child element with the `mat-placeholder` directive).\n   * @return {?}\n   */\n  _validatePlaceholders() {\n    if (this._control.placeholder && this._placeholderChild) {\n      throw getMatFormFieldPlaceholderConflictError();\n    }\n  }\n  /**\n   * Does any extra processing that is required when handling the hints.\n   * @return {?}\n   */\n  _processHints() {\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n  /**\n   * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n   * attribute being considered as `align=\"start\"`.\n   * @return {?}\n   */\n  _validateHints() {\n    if (this._hintChildren) {\n      let /** @type {?} */startHint;\n      let /** @type {?} */endHint;\n      this._hintChildren.forEach(hint => {\n        if (hint.align === 'start') {\n          if (startHint || this.hintLabel) {\n            throw getMatFormFieldDuplicatedHintError('start');\n          }\n          startHint = hint;\n        } else if (hint.align === 'end') {\n          if (endHint) {\n            throw getMatFormFieldDuplicatedHintError('end');\n          }\n          endHint = hint;\n        }\n      });\n    }\n  }\n  /**\n   * Sets the list of element IDs that describe the child control. This allows the control to update\n   * its `aria-describedby` attribute accordingly.\n   * @return {?}\n   */\n  _syncDescribedByIds() {\n    if (this._control) {\n      let /** @type {?} */ids = [];\n      if (this._getDisplayedMessages() === 'hint') {\n        let /** @type {?} */startHint = this._hintChildren ? this._hintChildren.find(hint => hint.align === 'start') : null;\n        let /** @type {?} */endHint = this._hintChildren ? this._hintChildren.find(hint => hint.align === 'end') : null;\n        if (startHint) {\n          ids.push(startHint.id);\n        } else if (this._hintLabel) {\n          ids.push(this._hintLabelId);\n        }\n        if (endHint) {\n          ids.push(endHint.id);\n        }\n      } else if (this._errorChildren) {\n        ids = this._errorChildren.map(error => error.id);\n      }\n      this._control.setDescribedByIds(ids);\n    }\n  }\n  /**\n   * Throws an error if the form field's control is missing.\n   * @return {?}\n   */\n  _validateControlChild() {\n    if (!this._control) {\n      throw getMatFormFieldMissingControlError();\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatFormFieldModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatFormFieldModule, MatError, MatFormFieldBase, _MatFormFieldMixinBase, MatFormField, MatFormFieldControl, getMatFormFieldPlaceholderConflictError, getMatFormFieldDuplicatedHintError, getMatFormFieldMissingControlError, MatHint, MatPlaceholder, MatPrefix, MatSuffix, MatLabel, matFormFieldAnimations };\n//# sourceMappingURL=form-field.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}