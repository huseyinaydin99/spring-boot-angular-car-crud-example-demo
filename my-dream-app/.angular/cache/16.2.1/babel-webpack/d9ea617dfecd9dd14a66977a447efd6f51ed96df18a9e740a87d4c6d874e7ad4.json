{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, EventEmitter, Injectable, Input, NgModule, Optional, Output, SkipSelf, ViewEncapsulation, isDevMode } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { CdkColumnDef } from '@angular/cdk/table';\nimport { merge } from 'rxjs/observable/merge';\nimport { AnimationCurves, AnimationDurations, mixinDisabled } from '@angular/material/core';\nimport { Subject } from 'rxjs/Subject';\nimport { animate, animateChild, keyframes, query, state, style, transition, trigger } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} id\n * @return {?}\n */\nfunction getSortDuplicateSortableIdError(id) {\n  return Error(`Cannot have two MatSortables with the same id (${id}).`);\n}\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getSortHeaderNotContainedWithinSortError() {\n  return Error(`MatSortHeader must be placed within a parent element with the MatSort directive.`);\n}\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getSortHeaderMissingIdError() {\n  return Error(`MatSortHeader must be provided with a unique id.`);\n}\n/**\n * \\@docs-private\n * @param {?} direction\n * @return {?}\n */\nfunction getSortInvalidDirectionError(direction) {\n  return Error(`${direction} is not a valid sort direction ('asc' or 'desc').`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface for a directive that holds sorting state consumed by `MatSortHeader`.\n * @record\n */\n\n/**\n * The current sort state.\n * @record\n */\n\n/**\n * \\@docs-private\n */\nclass MatSortBase {}\nconst _MatSortMixinBase = mixinDisabled(MatSortBase);\n/**\n * Container for MatSortables to manage the sort state and provide default sort parameters.\n */\nclass MatSort extends _MatSortMixinBase {\n  constructor() {\n    super(...arguments);\n    /**\n     * Collection of all registered sortables that this directive manages.\n     */\n    this.sortables = new Map();\n    /**\n     * Used to notify any child components listening to state changes.\n     */\n    this._stateChanges = new Subject();\n    /**\n     * The direction to set when an MatSortable is initially sorted.\n     * May be overriden by the MatSortable's sort start.\n     */\n    this.start = 'asc';\n    this._direction = '';\n    /**\n     * Event emitted when the user changes either the active sort or sort direction.\n     */\n    this.sortChange = new EventEmitter();\n  }\n  /**\n   * The sort direction of the currently active MatSortable.\n   * @return {?}\n   */\n  get direction() {\n    return this._direction;\n  }\n  /**\n   * @param {?} direction\n   * @return {?}\n   */\n  set direction(direction) {\n    if (isDevMode() && direction && direction !== 'asc' && direction !== 'desc') {\n      throw getSortInvalidDirectionError(direction);\n    }\n    this._direction = direction;\n  }\n  /**\n   * Whether to disable the user from clearing the sort by finishing the sort direction cycle.\n   * May be overriden by the MatSortable's disable clear input.\n   * @return {?}\n   */\n  get disableClear() {\n    return this._disableClear;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set disableClear(v) {\n    this._disableClear = coerceBooleanProperty(v);\n  }\n  /**\n   * Register function to be used by the contained MatSortables. Adds the MatSortable to the\n   * collection of MatSortables.\n   * @param {?} sortable\n   * @return {?}\n   */\n  register(sortable) {\n    if (!sortable.id) {\n      throw getSortHeaderMissingIdError();\n    }\n    if (this.sortables.has(sortable.id)) {\n      throw getSortDuplicateSortableIdError(sortable.id);\n    }\n    this.sortables.set(sortable.id, sortable);\n  }\n  /**\n   * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the\n   * collection of contained MatSortables.\n   * @param {?} sortable\n   * @return {?}\n   */\n  deregister(sortable) {\n    this.sortables.delete(sortable.id);\n  }\n  /**\n   * Sets the active sort id and determines the new sort direction.\n   * @param {?} sortable\n   * @return {?}\n   */\n  sort(sortable) {\n    if (this.active != sortable.id) {\n      this.active = sortable.id;\n      this.direction = sortable.start ? sortable.start : this.start;\n    } else {\n      this.direction = this.getNextSortDirection(sortable);\n    }\n    this.sortChange.emit({\n      active: this.active,\n      direction: this.direction\n    });\n  }\n  /**\n   * Returns the next sort direction of the active sortable, checking for potential overrides.\n   * @param {?} sortable\n   * @return {?}\n   */\n  getNextSortDirection(sortable) {\n    if (!sortable) {\n      return '';\n    }\n    // Get the sort direction cycle with the potential sortable overrides.\n    const /** @type {?} */disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;\n    let /** @type {?} */sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);\n    // Get and return the next direction in the cycle\n    let /** @type {?} */nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;\n    if (nextDirectionIndex >= sortDirectionCycle.length) {\n      nextDirectionIndex = 0;\n    }\n    return sortDirectionCycle[nextDirectionIndex];\n  }\n  /**\n   * @return {?}\n   */\n  ngOnChanges() {\n    this._stateChanges.next();\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._stateChanges.complete();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Returns the sort direction cycle to use given the provided parameters of order and clear.\n * @param {?} start\n * @param {?} disableClear\n * @return {?}\n */\nfunction getSortDirectionCycle(start, disableClear) {\n  let /** @type {?} */sortOrder = ['asc', 'desc'];\n  if (start == 'desc') {\n    sortOrder.reverse();\n  }\n  if (!disableClear) {\n    sortOrder.push('');\n  }\n  return sortOrder;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * To modify the labels and text displayed, create a new instance of MatSortHeaderIntl and\n * include it in a custom provider.\n */\nclass MatSortHeaderIntl {\n  constructor() {\n    /**\n     * Stream that emits whenever the labels here are changed. Use this to notify\n     * components if the labels have changed after initialization.\n     */\n    this.changes = new Subject();\n    /**\n     * ARIA label for the sorting button.\n     */\n    this.sortButtonLabel = id => {\n      return `Change sorting for ${id}`;\n    };\n    /**\n     * A label to describe the current sort (visible only to screenreaders).\n     */\n    this.sortDescriptionLabel = (id, direction) => {\n      return `Sorted by ${id} ${direction == 'asc' ? 'ascending' : 'descending'}`;\n    };\n  }\n}\n\n/** @nocollapse */\n\n/**\n * \\@docs-private\n * @param {?} parentIntl\n * @return {?}\n */\nfunction MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {\n  return parentIntl || new MatSortHeaderIntl();\n}\n/**\n * \\@docs-private\n */\nconst MAT_SORT_HEADER_INTL_PROVIDER = {\n  // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.\n  provide: MatSortHeaderIntl,\n  deps: [[new Optional(), new SkipSelf(), MatSortHeaderIntl]],\n  useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst SORT_ANIMATION_TRANSITION = AnimationDurations.ENTERING + ' ' + AnimationCurves.STANDARD_CURVE;\n/**\n * Animations used by MatSort.\n */\nconst matSortAnimations = {\n  /** Animation that moves the sort indicator. */\n  indicator: trigger('indicator', [state('active-asc, asc', style({\n    transform: 'translateY(0px)'\n  })),\n  // 10px is the height of the sort indicator, minus the width of the pointers\n  state('active-desc, desc', style({\n    transform: 'translateY(10px)'\n  })), transition('active-asc <=> active-desc', animate(SORT_ANIMATION_TRANSITION))]),\n  /** Animation that rotates the left pointer of the indicator based on the sorting direction. */\n  leftPointer: trigger('leftPointer', [state('active-asc, asc', style({\n    transform: 'rotate(-45deg)'\n  })), state('active-desc, desc', style({\n    transform: 'rotate(45deg)'\n  })), transition('active-asc <=> active-desc', animate(SORT_ANIMATION_TRANSITION))]),\n  /** Animation that rotates the right pointer of the indicator based on the sorting direction. */\n  rightPointer: trigger('rightPointer', [state('active-asc, asc', style({\n    transform: 'rotate(45deg)'\n  })), state('active-desc, desc', style({\n    transform: 'rotate(-45deg)'\n  })), transition('active-asc <=> active-desc', animate(SORT_ANIMATION_TRANSITION))]),\n  /** Animation that controls the arrow opacity. */\n  arrowOpacity: trigger('arrowOpacity', [state('desc-to-active, asc-to-active, active', style({\n    opacity: 1\n  })), state('desc-to-hint, asc-to-hint, hint', style({\n    opacity: .54\n  })), state('hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc', style({\n    opacity: 0\n  })),\n  // Transition between all states except for immediate transitions\n  transition('* => asc, * => desc, * => active, * => hint', animate('0ms')), transition('* <=> *', animate(SORT_ANIMATION_TRANSITION))]),\n  /**\n     * Animation for the translation of the arrow as a whole. States are separated into two\n     * groups: ones with animations and others that are immediate. Immediate states are asc, desc,\n     * peek, and active. The other states define a specific animation (source-to-destination)\n     * and are determined as a function of their prev user-perceived state and what the next state\n     * should be.\n     */\n  arrowPosition: trigger('arrowPosition', [\n  // Hidden Above => Hint Center\n  transition('* => desc-to-hint, * => desc-to-active', animate(SORT_ANIMATION_TRANSITION, keyframes([style({\n    transform: 'translateY(-25%)'\n  }), style({\n    transform: 'translateY(0)'\n  })]))),\n  // Hint Center => Hidden Below\n  transition('* => hint-to-desc, * => active-to-desc', animate(SORT_ANIMATION_TRANSITION, keyframes([style({\n    transform: 'translateY(0)'\n  }), style({\n    transform: 'translateY(25%)'\n  })]))),\n  // Hidden Below => Hint Center\n  transition('* => asc-to-hint, * => asc-to-active', animate(SORT_ANIMATION_TRANSITION, keyframes([style({\n    transform: 'translateY(25%)'\n  }), style({\n    transform: 'translateY(0)'\n  })]))),\n  // Hint Center => Hidden Above\n  transition('* => hint-to-asc, * => active-to-asc', animate(SORT_ANIMATION_TRANSITION, keyframes([style({\n    transform: 'translateY(0)'\n  }), style({\n    transform: 'translateY(-25%)'\n  })]))), state('desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active', style({\n    transform: 'translateY(0)'\n  })), state('hint-to-desc, active-to-desc, desc', style({\n    transform: 'translateY(-25%)'\n  })), state('hint-to-asc, active-to-asc, asc', style({\n    transform: 'translateY(25%)'\n  }))]),\n  /** Necessary trigger that calls animate on children animations. */\n  allowChildren: trigger('allowChildren', [transition('* <=> *', [query('@*', animateChild(), {\n    optional: true\n  })])])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\nclass MatSortHeaderBase {}\nconst _MatSortHeaderMixinBase = mixinDisabled(MatSortHeaderBase);\n/**\n * States describing the arrow's animated position (animating fromState to toState).\n * If the fromState is not defined, there will be no animated transition to the toState.\n * \\@docs-private\n * @record\n */\n\n/**\n * Applies sorting behavior (click to change sort) and styles to an element, including an\n * arrow to display the current sort direction.\n *\n * Must be provided with an id and contained within a parent MatSort directive.\n *\n * If used on header cells in a CdkTable, it will automatically default its id from its containing\n * column definition.\n */\nclass MatSortHeader extends _MatSortHeaderMixinBase {\n  /**\n   * @param {?} _intl\n   * @param {?} changeDetectorRef\n   * @param {?} _sort\n   * @param {?} _cdkColumnDef\n   */\n  constructor(_intl, changeDetectorRef, _sort, _cdkColumnDef) {\n    super();\n    this._intl = _intl;\n    this._sort = _sort;\n    this._cdkColumnDef = _cdkColumnDef;\n    /**\n     * Flag set to true when the indicator should be displayed while the sort is not active. Used to\n     * provide an affordance that the header is sortable by showing on focus and hover.\n     */\n    this._showIndicatorHint = false;\n    /**\n     * The direction the arrow should be facing according to the current state.\n     */\n    this._arrowDirection = '';\n    /**\n     * Whether the view state animation should show the transition between the `from` and `to` states.\n     */\n    this._disableViewStateAnimation = false;\n    /**\n     * Sets the position of the arrow that displays when sorted.\n     */\n    this.arrowPosition = 'after';\n    if (!_sort) {\n      throw getSortHeaderNotContainedWithinSortError();\n    }\n    this._rerenderSubscription = merge(_sort.sortChange, _sort._stateChanges, _intl.changes).subscribe(() => {\n      if (this._isSorted()) {\n        this._updateArrowDirection();\n      }\n      // If this header was recently active and now no longer sorted, animate away the arrow.\n      if (!this._isSorted() && this._viewState && this._viewState.toState === 'active') {\n        this._disableViewStateAnimation = false;\n        this._setAnimationTransitionState({\n          fromState: 'active',\n          toState: this._arrowDirection\n        });\n      }\n      changeDetectorRef.markForCheck();\n    });\n  }\n  /**\n   * Overrides the disable clear value of the containing MatSort for this MatSortable.\n   * @return {?}\n   */\n  get disableClear() {\n    return this._disableClear;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set disableClear(v) {\n    this._disableClear = coerceBooleanProperty(v);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    if (!this.id && this._cdkColumnDef) {\n      this.id = this._cdkColumnDef.name;\n    }\n    // Initialize the direction of the arrow and set the view state to be immediately that state.\n    this._updateArrowDirection();\n    this._setAnimationTransitionState({\n      toState: this._isSorted() ? 'active' : this._arrowDirection\n    });\n    this._sort.register(this);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._sort.deregister(this);\n    this._rerenderSubscription.unsubscribe();\n  }\n  /**\n   * Sets the \"hint\" state such that the arrow will be semi-transparently displayed as a hint to the\n   * user showing what the active sort will become. If set to false, the arrow will fade away.\n   * @param {?} visible\n   * @return {?}\n   */\n  _setIndicatorHintVisible(visible) {\n    // No-op if the sort header is disabled - should not make the hint visible.\n    if (this._isDisabled() && visible) {\n      return;\n    }\n    this._showIndicatorHint = visible;\n    if (!this._isSorted()) {\n      this._updateArrowDirection();\n      if (this._showIndicatorHint) {\n        this._setAnimationTransitionState({\n          fromState: this._arrowDirection,\n          toState: 'hint'\n        });\n      } else {\n        this._setAnimationTransitionState({\n          fromState: 'hint',\n          toState: this._arrowDirection\n        });\n      }\n    }\n  }\n  /**\n   * Sets the animation transition view state for the arrow's position and opacity. If the\n   * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that\n   * no animation appears.\n   * @param {?} viewState\n   * @return {?}\n   */\n  _setAnimationTransitionState(viewState) {\n    this._viewState = viewState;\n    // If the animation for arrow position state (opacity/translation) should be disabled,\n    // remove the fromState so that it jumps right to the toState.\n    if (this._disableViewStateAnimation) {\n      this._viewState = {\n        toState: viewState.toState\n      };\n    }\n  }\n  /**\n   * Triggers the sort on this sort header and removes the indicator hint.\n   * @return {?}\n   */\n  _handleClick() {\n    if (this._isDisabled()) {\n      return;\n    }\n    this._sort.sort(this);\n    // Do not show the animation if the header was already shown in the right position.\n    if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {\n      this._disableViewStateAnimation = true;\n    }\n    // If the arrow is now sorted, animate the arrow into place. Otherwise, animate it away into\n    // the direction it is facing.\n    const /** @type {?} */viewState = this._isSorted() ? {\n      fromState: this._arrowDirection,\n      toState: 'active'\n    } : {\n      fromState: 'active',\n      toState: this._arrowDirection\n    };\n    this._setAnimationTransitionState(viewState);\n    this._showIndicatorHint = false;\n  }\n  /**\n   * Whether this MatSortHeader is currently sorted in either ascending or descending order.\n   * @return {?}\n   */\n  _isSorted() {\n    return this._sort.active == this.id && (this._sort.direction === 'asc' || this._sort.direction === 'desc');\n  }\n  /**\n   * Returns the animation state for the arrow direction (indicator and pointers).\n   * @return {?}\n   */\n  _getArrowDirectionState() {\n    return `${this._isSorted() ? 'active-' : ''}${this._arrowDirection}`;\n  }\n  /**\n   * Returns the arrow position state (opacity, translation).\n   * @return {?}\n   */\n  _getArrowViewState() {\n    const /** @type {?} */fromState = this._viewState.fromState;\n    return (fromState ? `${fromState}-to-` : '') + this._viewState.toState;\n  }\n  /**\n   * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be\n   * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently\n   * active sorted direction. The reason this is updated through a function is because the direction\n   * should only be changed at specific times - when deactivated but the hint is displayed and when\n   * the sort is active and the direction changes. Otherwise the arrow's direction should linger\n   * in cases such as the sort becoming deactivated but we want to animate the arrow away while\n   * preserving its direction, even though the next sort direction is actually different and should\n   * only be changed once the arrow displays again (hint or activation).\n   * @return {?}\n   */\n  _updateArrowDirection() {\n    this._arrowDirection = this._isSorted() ? this._sort.direction : this.start || this._sort.start;\n  }\n  /**\n   * @return {?}\n   */\n  _isDisabled() {\n    return this._sort.disabled || this.disabled;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatSortModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatSortModule, MatSortHeaderBase, _MatSortHeaderMixinBase, MatSortHeader, MatSortHeaderIntl, MAT_SORT_HEADER_INTL_PROVIDER_FACTORY, MAT_SORT_HEADER_INTL_PROVIDER, MatSortBase, _MatSortMixinBase, MatSort, matSortAnimations };\n//# sourceMappingURL=sort.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}