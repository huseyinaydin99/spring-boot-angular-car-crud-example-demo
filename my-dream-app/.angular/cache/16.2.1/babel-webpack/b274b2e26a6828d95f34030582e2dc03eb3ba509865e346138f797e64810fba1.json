{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { A11yModule, FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UNIQUE_SELECTION_DISPATCHER_PROVIDER, UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, Input, NgModule, Optional, Output, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatCommonModule, mixinDisabled } from '@angular/material/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\nclass MatButtonToggleGroupBase {}\nconst _MatButtonToggleGroupMixinBase = mixinDisabled(MatButtonToggleGroupBase);\n/**\n * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * \\@docs-private\n */\nconst MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatButtonToggleGroup),\n  multi: true\n};\nlet _uniqueIdCounter = 0;\n/**\n * Change event object emitted by MatButtonToggle.\n */\nclass MatButtonToggleChange {}\n/**\n * Exclusive selection button toggle group that behaves like a radio-button group.\n */\nclass MatButtonToggleGroup extends _MatButtonToggleGroupMixinBase {\n  /**\n   * @param {?} _changeDetector\n   */\n  constructor(_changeDetector) {\n    super();\n    this._changeDetector = _changeDetector;\n    /**\n     * The method to be called in order to update ngModel.\n     * Now `ngModel` binding is not supported in multiple selection mode.\n     */\n    this._controlValueAccessorChangeFn = () => {};\n    /**\n     * onTouch function registered via registerOnTouch (ControlValueAccessor).\n     */\n    this._onTouched = () => {};\n    this._name = `mat-button-toggle-group-${_uniqueIdCounter++}`;\n    this._vertical = false;\n    this._value = null;\n    /**\n     * Event that emits whenever the value of the group changes.\n     * Used to facilitate two-way data binding.\n     * \\@docs-private\n     */\n    this.valueChange = new EventEmitter();\n    this._selected = null;\n    /**\n     * Event emitted when the group's value changes.\n     */\n    this.change = new EventEmitter();\n  }\n  /**\n   * `name` attribute for the underlying `input` element.\n   * @return {?}\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set name(value) {\n    this._name = value;\n    this._updateButtonToggleNames();\n  }\n  /**\n   * Whether the toggle group is vertical.\n   * @return {?}\n   */\n  get vertical() {\n    return this._vertical;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set vertical(value) {\n    this._vertical = coerceBooleanProperty(value);\n  }\n  /**\n   * Value of the toggle group.\n   * @return {?}\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set value(value) {\n    if (this._value != value) {\n      this._value = value;\n      this.valueChange.emit(value);\n      this._updateSelectedButtonToggleFromValue();\n    }\n  }\n  /**\n   * The currently selected button toggle, should match the value.\n   * @return {?}\n   */\n  get selected() {\n    return this._selected;\n  }\n  /**\n   * @param {?} selected\n   * @return {?}\n   */\n  set selected(selected) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    if (selected && !selected.checked) {\n      selected.checked = true;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _updateButtonToggleNames() {\n    if (this._buttonToggles) {\n      this._buttonToggles.forEach(toggle => {\n        toggle.name = this._name;\n      });\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _updateSelectedButtonToggleFromValue() {\n    let /** @type {?} */isAlreadySelected = this._selected != null && this._selected.value == this._value;\n    if (this._buttonToggles != null && !isAlreadySelected) {\n      let /** @type {?} */matchingButtonToggle = this._buttonToggles.filter(buttonToggle => buttonToggle.value == this._value)[0];\n      if (matchingButtonToggle) {\n        this.selected = matchingButtonToggle;\n      } else if (this.value == null) {\n        this.selected = null;\n        this._buttonToggles.forEach(buttonToggle => {\n          buttonToggle.checked = false;\n        });\n      }\n    }\n  }\n  /**\n   * Dispatch change event with current selection and group value.\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    let /** @type {?} */event = new MatButtonToggleChange();\n    event.source = this._selected;\n    event.value = this._value;\n    this._controlValueAccessorChangeFn(event.value);\n    this.change.emit(event);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this._onTouched = fn;\n  }\n  /**\n   * @param {?} isDisabled\n   * @return {?}\n   */\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this._markButtonTogglesForCheck();\n  }\n  /**\n   * @return {?}\n   */\n  _markButtonTogglesForCheck() {\n    if (this._buttonToggles) {\n      this._buttonToggles.forEach(toggle => toggle._markForCheck());\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Multiple selection button-toggle group. `ngModel` is not supported in this mode.\n */\nclass MatButtonToggleGroupMultiple extends _MatButtonToggleGroupMixinBase {\n  constructor() {\n    super(...arguments);\n    this._vertical = false;\n  }\n  /**\n   * Whether the toggle group is vertical.\n   * @return {?}\n   */\n  get vertical() {\n    return this._vertical;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set vertical(value) {\n    this._vertical = coerceBooleanProperty(value);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Single button inside of a toggle group.\n */\nclass MatButtonToggle {\n  /**\n   * @param {?} toggleGroup\n   * @param {?} toggleGroupMultiple\n   * @param {?} _changeDetectorRef\n   * @param {?} _buttonToggleDispatcher\n   * @param {?} _elementRef\n   * @param {?} _focusMonitor\n   */\n  constructor(toggleGroup, toggleGroupMultiple, _changeDetectorRef, _buttonToggleDispatcher, _elementRef, _focusMonitor) {\n    this._changeDetectorRef = _changeDetectorRef;\n    this._buttonToggleDispatcher = _buttonToggleDispatcher;\n    this._elementRef = _elementRef;\n    this._focusMonitor = _focusMonitor;\n    /**\n     * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\n     * take precedence so this may be omitted.\n     */\n    this.ariaLabel = '';\n    /**\n     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n     */\n    this.ariaLabelledby = null;\n    /**\n     * Whether or not the button toggle is a single selection.\n     */\n    this._isSingleSelector = false;\n    /**\n     * Unregister function for _buttonToggleDispatcher\n     */\n    this._removeUniqueSelectionListener = () => {};\n    this._checked = false;\n    this._value = null;\n    this._disabled = false;\n    /**\n     * Event emitted when the group value changes.\n     */\n    this.change = new EventEmitter();\n    this.buttonToggleGroup = toggleGroup;\n    this.buttonToggleGroupMultiple = toggleGroupMultiple;\n    if (this.buttonToggleGroup) {\n      this._removeUniqueSelectionListener = _buttonToggleDispatcher.listen((id, name) => {\n        if (id != this.id && name == this.name) {\n          this.checked = false;\n          this._changeDetectorRef.markForCheck();\n        }\n      });\n      this._type = 'radio';\n      this.name = this.buttonToggleGroup.name;\n      this._isSingleSelector = true;\n    } else {\n      // Even if there is no group at all, treat the button toggle as a checkbox so it can be\n      // toggled on or off.\n      this._type = 'checkbox';\n      this._isSingleSelector = false;\n    }\n  }\n  /**\n   * Unique ID for the underlying `input` element.\n   * @return {?}\n   */\n  get inputId() {\n    return `${this.id}-input`;\n  }\n  /**\n   * Whether the button is checked.\n   * @return {?}\n   */\n  get checked() {\n    return this._checked;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set checked(value) {\n    if (this._isSingleSelector && value) {\n      // Notify all button toggles with the same name (in the same group) to un-check.\n      this._buttonToggleDispatcher.notify(this.id, this.name);\n      this._changeDetectorRef.markForCheck();\n    }\n    this._checked = value;\n    if (value && this._isSingleSelector && this.buttonToggleGroup.value != this.value) {\n      this.buttonToggleGroup.selected = this;\n    }\n  }\n  /**\n   * MatButtonToggleGroup reads this to assign its own value.\n   * @return {?}\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set value(value) {\n    if (this._value != value) {\n      if (this.buttonToggleGroup != null && this.checked) {\n        this.buttonToggleGroup.value = value;\n      }\n      this._value = value;\n    }\n  }\n  /**\n   * Whether the button is disabled.\n   * @return {?}\n   */\n  get disabled() {\n    return this._disabled || this.buttonToggleGroup != null && this.buttonToggleGroup.disabled || this.buttonToggleGroupMultiple != null && this.buttonToggleGroupMultiple.disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    if (this.id == null) {\n      this.id = `mat-button-toggle-${_uniqueIdCounter++}`;\n    }\n    if (this.buttonToggleGroup && this._value == this.buttonToggleGroup.value) {\n      this._checked = true;\n    }\n    this._focusMonitor.monitor(this._elementRef.nativeElement, true);\n  }\n  /**\n   * Focuses the button.\n   * @return {?}\n   */\n  focus() {\n    this._inputElement.nativeElement.focus();\n  }\n  /**\n   * Toggle the state of the current button toggle.\n   * @return {?}\n   */\n  _toggle() {\n    this.checked = !this.checked;\n  }\n  /**\n   * Checks the button toggle due to an interaction with the underlying native input.\n   * @param {?} event\n   * @return {?}\n   */\n  _onInputChange(event) {\n    event.stopPropagation();\n    if (this._isSingleSelector) {\n      // Propagate the change one-way via the group, which will in turn mark this\n      // button toggle as checked.\n      let /** @type {?} */groupValueChanged = this.buttonToggleGroup.selected != this;\n      this.checked = true;\n      this.buttonToggleGroup.selected = this;\n      this.buttonToggleGroup._onTouched();\n      if (groupValueChanged) {\n        this.buttonToggleGroup._emitChangeEvent();\n      }\n    } else {\n      this._toggle();\n    }\n    // Emit a change event when the native input does.\n    this._emitChangeEvent();\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onInputClick(event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `slide-toggle` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n  /**\n   * Dispatch change event with current value.\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    let /** @type {?} */event = new MatButtonToggleChange();\n    event.source = this;\n    event.value = this._value;\n    this.change.emit(event);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._removeUniqueSelectionListener();\n  }\n  /**\n   * Marks the button toggle as needing checking for change detection.\n   * This method is exposed because the parent button toggle group will directly\n   * update bound properties of the radio button.\n   * @return {?}\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update button toggle's status\n    this._changeDetectorRef.markForCheck();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatButtonToggleModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatButtonToggleGroupBase, _MatButtonToggleGroupMixinBase, MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggleGroupMultiple, MatButtonToggle, MatButtonToggleModule };\n//# sourceMappingURL=button-toggle.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}