{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { A11yModule, FocusMonitor } from '@angular/cdk/a11y';\nimport { UNIQUE_SELECTION_DISPATCHER_PROVIDER, UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, Input, NgModule, Optional, Output, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { MatCommonModule, MatRipple, MatRippleModule, mixinColor, mixinDisableRipple, mixinDisabled, mixinTabIndex } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * \\@docs-private\n */\nconst MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true\n};\n/**\n * Change event object emitted by MatRadio and MatRadioGroup.\n */\nclass MatRadioChange {\n  /**\n   * @param {?} source\n   * @param {?} value\n   */\n  constructor(source, value) {\n    this.source = source;\n    this.value = value;\n  }\n}\n/**\n * \\@docs-private\n */\nclass MatRadioGroupBase {}\nconst _MatRadioGroupMixinBase = mixinDisabled(MatRadioGroupBase);\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\nclass MatRadioGroup extends _MatRadioGroupMixinBase {\n  /**\n   * @param {?} _changeDetector\n   */\n  constructor(_changeDetector) {\n    super();\n    this._changeDetector = _changeDetector;\n    /**\n     * Selected value for group. Should equal the value of the selected radio button if there *is*\n     * a corresponding radio button with a matching value. If there is *not* such a corresponding\n     * radio button, this value persists to be applied in case a new radio button is added with a\n     * matching value.\n     */\n    this._value = null;\n    /**\n     * The HTML name attribute applied to radio buttons in this group.\n     */\n    this._name = `mat-radio-group-${nextUniqueId++}`;\n    /**\n     * The currently selected radio button. Should match value.\n     */\n    this._selected = null;\n    /**\n     * Whether the `value` has been set to its initial value.\n     */\n    this._isInitialized = false;\n    /**\n     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n     */\n    this._labelPosition = 'after';\n    /**\n     * Whether the radio group is disabled.\n     */\n    this._disabled = false;\n    /**\n     * Whether the radio group is required.\n     */\n    this._required = false;\n    /**\n     * The method to be called in order to update ngModel\n     */\n    this._controlValueAccessorChangeFn = () => {};\n    /**\n     * onTouch function registered via registerOnTouch (ControlValueAccessor).\n     * \\@docs-private\n     */\n    this.onTouched = () => {};\n    /**\n     * Event emitted when the group value changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * a radio button (the same behavior as `<input type-\"radio\">`).\n     */\n    this.change = new EventEmitter();\n  }\n  /**\n   * Name of the radio button group. All radio buttons inside this group will use this name.\n   * @return {?}\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set name(value) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n  /**\n   * Alignment of the radio-buttons relative to their labels. Can be 'before' or 'after'.\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get align() {\n    // align refers to the checkbox relative to the label, while labelPosition refers to the\n    // label relative to the checkbox. As such, they are inverted.\n    return this.labelPosition == 'after' ? 'start' : 'end';\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set align(v) {\n    this.labelPosition = v == 'start' ? 'after' : 'before';\n  }\n  /**\n   * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n   * @return {?}\n   */\n  get labelPosition() {\n    return this._labelPosition;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set labelPosition(v) {\n    this._labelPosition = v == 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n  /**\n   * Value of the radio button.\n   * @return {?}\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * @param {?} newValue\n   * @return {?}\n   */\n  set value(newValue) {\n    if (this._value != newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n  /**\n   * Whether the radio button is selected.\n   * @return {?}\n   */\n  get selected() {\n    return this._selected;\n  }\n  /**\n   * @param {?} selected\n   * @return {?}\n   */\n  set selected(selected) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n  /**\n   * Whether the radio group is disabled\n   * @return {?}\n   */\n  get disabled() {\n    return this._disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n  /**\n   * Whether the radio group is required\n   * @return {?}\n   */\n  get required() {\n    return this._required;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n    this._markRadiosForCheck();\n  }\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n  }\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   * @return {?}\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _updateRadioButtonNames() {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n      });\n    }\n  }\n  /**\n   * Updates the `selected` radio button from the internal _value state.\n   * @return {?}\n   */\n  _updateSelectedRadioFromValue() {\n    // If the value already matches the selected radio, do nothing.\n    const /** @type {?} */isAlreadySelected = this._selected != null && this._selected.value == this._value;\n    if (this._radios != null && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value == radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n  /**\n   * Dispatch change event with current selection and group value.\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange( /** @type {?} */this._selected, this._value));\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} fn Callback to be registered.\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param {?} fn Callback to be registered.\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param {?} isDisabled Whether the control should be disabled.\n   * @return {?}\n   */\n  setDisabledState(isDisabled) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * \\@docs-private\n */\nclass MatRadioButtonBase {\n  /**\n   * @param {?} _elementRef\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n}\n// As per Material design specifications the selection control radio should use the accent color\n// palette by default. https://material.io/guidelines/components/selection-controls.html\nconst _MatRadioButtonMixinBase = mixinColor(mixinDisableRipple(mixinTabIndex(MatRadioButtonBase)), 'accent');\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\nclass MatRadioButton extends _MatRadioButtonMixinBase {\n  /**\n   * @param {?} radioGroup\n   * @param {?} elementRef\n   * @param {?} _changeDetector\n   * @param {?} _focusMonitor\n   * @param {?} _radioDispatcher\n   */\n  constructor(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher) {\n    super(elementRef);\n    this._changeDetector = _changeDetector;\n    this._focusMonitor = _focusMonitor;\n    this._radioDispatcher = _radioDispatcher;\n    this._uniqueId = `mat-radio-${++nextUniqueId}`;\n    /**\n     * The unique ID for the radio button.\n     */\n    this.id = this._uniqueId;\n    /**\n     * Event emitted when the checked state of this radio button changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * the radio button (the same behavior as `<input type-\"radio\">`).\n     */\n    this.change = new EventEmitter();\n    /**\n     * Whether this radio is checked.\n     */\n    this._checked = false;\n    /**\n     * Value assigned to this radio.\n     */\n    this._value = null;\n    /**\n     * Unregister function for _radioDispatcher\n     */\n    this._removeUniqueSelectionListener = () => {};\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._removeUniqueSelectionListener = _radioDispatcher.listen((id, name) => {\n      if (id != this.id && name == this.name) {\n        this.checked = false;\n      }\n    });\n  }\n  /**\n   * Whether this radio button is checked.\n   * @return {?}\n   */\n  get checked() {\n    return this._checked;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set checked(value) {\n    const /** @type {?} */newCheckedState = coerceBooleanProperty(value);\n    if (this._checked != newCheckedState) {\n      this._checked = newCheckedState;\n      if (newCheckedState && this.radioGroup && this.radioGroup.value != this.value) {\n        this.radioGroup.selected = this;\n      } else if (!newCheckedState && this.radioGroup && this.radioGroup.value == this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n      if (newCheckedState) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n  /**\n   * The value of this radio button.\n   * @return {?}\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set value(value) {\n    if (this._value != value) {\n      this._value = value;\n      if (this.radioGroup != null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value == value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n  /**\n   * Whether or not the radio-button should appear before or after the label.\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get align() {\n    // align refers to the checkbox relative to the label, while labelPosition refers to the\n    // label relative to the checkbox. As such, they are inverted.\n    return this.labelPosition == 'after' ? 'start' : 'end';\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set align(v) {\n    this.labelPosition = v == 'start' ? 'after' : 'before';\n  }\n  /**\n   * Whether the label should appear after or before the radio button. Defaults to 'after'\n   * @return {?}\n   */\n  get labelPosition() {\n    return this._labelPosition || this.radioGroup && this.radioGroup.labelPosition || 'after';\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  /**\n   * Whether the radio button is disabled.\n   * @return {?}\n   */\n  get disabled() {\n    return this._disabled || this.radioGroup != null && this.radioGroup.disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether the radio button is required.\n   * @return {?}\n   */\n  get required() {\n    return this._required || this.radioGroup && this.radioGroup.required;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n  }\n  /**\n   * ID of the native input element inside `<mat-radio-button>`\n   * @return {?}\n   */\n  get inputId() {\n    return `${this.id || this._uniqueId}-input`;\n  }\n  /**\n   * Focuses the radio button.\n   * @return {?}\n   */\n  focus() {\n    this._focusMonitor.focusVia(this._inputElement.nativeElement, 'keyboard');\n  }\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   * @return {?}\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterViewInit() {\n    this._focusMonitor.monitor(this._inputElement.nativeElement).subscribe(focusOrigin => this._onInputFocusChange(focusOrigin));\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._inputElement.nativeElement);\n    this._removeUniqueSelectionListener();\n  }\n  /**\n   * Dispatch change event with current value.\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n  /**\n   * @return {?}\n   */\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n  _onInputClick(event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `radio-button` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n  }\n  /**\n   * Triggered when the radio button received a click or the input recognized any change.\n   * Clicking on a label element, will trigger a change event on the associated input.\n   * @param {?} event\n   * @return {?}\n   */\n  _onInputChange(event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n    const /** @type {?} */groupValueChanged = this.radioGroup && this.value != this.radioGroup.value;\n    this.checked = true;\n    this._emitChangeEvent();\n    if (this.radioGroup) {\n      this.radioGroup._controlValueAccessorChangeFn(this.value);\n      this.radioGroup._touch();\n      if (groupValueChanged) {\n        this.radioGroup._emitChangeEvent();\n      }\n    }\n  }\n  /**\n   * Function is called whenever the focus changes for the input element.\n   * @param {?} focusOrigin\n   * @return {?}\n   */\n  _onInputFocusChange(focusOrigin) {\n    if (!this._focusRipple && focusOrigin === 'keyboard') {\n      this._focusRipple = this._ripple.launch(0, 0, {\n        persistent: true\n      });\n    } else if (!focusOrigin) {\n      if (this.radioGroup) {\n        this.radioGroup._touch();\n      }\n      if (this._focusRipple) {\n        this._focusRipple.fadeOut();\n        this._focusRipple = null;\n      }\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatRadioModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatRadioModule, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroupBase, _MatRadioGroupMixinBase, MatRadioGroup, MatRadioButtonBase, _MatRadioButtonMixinBase, MatRadioButton };\n//# sourceMappingURL=radio.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}