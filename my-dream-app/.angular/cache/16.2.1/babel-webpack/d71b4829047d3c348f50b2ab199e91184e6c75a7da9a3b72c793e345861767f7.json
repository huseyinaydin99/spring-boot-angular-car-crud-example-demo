{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Subject } from 'rxjs/Subject';\nimport { Injectable, Optional, SkipSelf } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @abstract\n * @template T\n */\nclass DataSource {}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class to be used to power selecting one or more options from a list.\n * @template T\n */\nclass SelectionModel {\n  /**\n   * @param {?=} _multiple\n   * @param {?=} initiallySelectedValues\n   * @param {?=} _emitChanges\n   */\n  constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n    this._multiple = _multiple;\n    this._emitChanges = _emitChanges;\n    /**\n     * Currently-selected values.\n     */\n    this._selection = new Set();\n    /**\n     * Keeps track of the deselected options that haven't been emitted by the change event.\n     */\n    this._deselectedToEmit = [];\n    /**\n     * Keeps track of the selected options that haven't been emitted by the change event.\n     */\n    this._selectedToEmit = [];\n    /**\n     * Event emitted when the value has changed.\n     */\n    this.onChange = this._emitChanges ? new Subject() : null;\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      }\n      // Clear the array in order to avoid firing the change event for preselected values.\n      this._selectedToEmit.length = 0;\n    }\n  }\n  /**\n   * Selected values.\n   * @return {?}\n   */\n  get selected() {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n    return this._selected;\n  }\n  /**\n   * Selects a value or an array of values.\n   * @param {...?} values\n   * @return {?}\n   */\n  select(...values) {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._markSelected(value));\n    this._emitChangeEvent();\n  }\n  /**\n   * Deselects a value or an array of values.\n   * @param {...?} values\n   * @return {?}\n   */\n  deselect(...values) {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._unmarkSelected(value));\n    this._emitChangeEvent();\n  }\n  /**\n   * Toggles a value between selected and deselected.\n   * @param {?} value\n   * @return {?}\n   */\n  toggle(value) {\n    this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n  /**\n   * Clears all of the selected values.\n   * @return {?}\n   */\n  clear() {\n    this._unmarkAll();\n    this._emitChangeEvent();\n  }\n  /**\n   * Determines whether a value is selected.\n   * @param {?} value\n   * @return {?}\n   */\n  isSelected(value) {\n    return this._selection.has(value);\n  }\n  /**\n   * Determines whether the model does not have a value.\n   * @return {?}\n   */\n  isEmpty() {\n    return this._selection.size === 0;\n  }\n  /**\n   * Determines whether the model has a value.\n   * @return {?}\n   */\n  hasValue() {\n    return !this.isEmpty();\n  }\n  /**\n   * Sorts the selected values based on a predicate function.\n   * @param {?=} predicate\n   * @return {?}\n   */\n  sort(predicate) {\n    if (this._multiple && this._selected) {\n      this._selected.sort(predicate);\n    }\n  }\n  /**\n   * Emits a change event and clears the records of selected and deselected values.\n   * @return {?}\n   */\n  _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      if (this.onChange) {\n        this.onChange.next({\n          source: this,\n          added: this._selectedToEmit,\n          removed: this._deselectedToEmit\n        });\n      }\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n  /**\n   * Selects a value.\n   * @param {?} value\n   * @return {?}\n   */\n  _markSelected(value) {\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n      this._selection.add(value);\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n  /**\n   * Deselects a value.\n   * @param {?} value\n   * @return {?}\n   */\n  _unmarkSelected(value) {\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n  /**\n   * Clears out the selected values.\n   * @return {?}\n   */\n  _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   * @param {?} values\n   * @return {?}\n   */\n  _verifyValueAssignment(values) {\n    if (values.length > 1 && !this._multiple) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n}\n/**\n * Event emitted when the value of a MatSelectionModel has changed.\n * \\@docs-private\n * @record\n * @template T\n */\n\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @return {?}\n */\nfunction getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n  constructor() {\n    this._listeners = [];\n  }\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param {?} id ID of the item.\n   * @param {?} name Name of the item.\n   * @return {?}\n   */\n  notify(id, name) {\n    for (let /** @type {?} */listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n  /**\n   * Listen for future changes to item selection.\n   * @param {?} listener\n   * @return {?} Function used to deregister listener\n   */\n  listen(listener) {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter(registered => {\n        return listener !== registered;\n      });\n    };\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n}\n\n/** @nocollapse */\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @return {?}\n */\nfunction UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {\n  return parentDispatcher || new UniqueSelectionDispatcher();\n}\n/**\n * \\@docs-private\n */\nconst UNIQUE_SELECTION_DISPATCHER_PROVIDER = {\n  // If there is already a dispatcher available, use that. Otherwise, provide a new one.\n  provide: UniqueSelectionDispatcher,\n  deps: [[new Optional(), new SkipSelf(), UniqueSelectionDispatcher]],\n  useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UniqueSelectionDispatcher, UNIQUE_SELECTION_DISPATCHER_PROVIDER, DataSource, SelectionModel, getMultipleValuesInSingleSelectionError, UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY as Éµa };\n//# sourceMappingURL=collections.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}