{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Platform, PlatformModule, getSupportedInputTypes } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { Directive, ElementRef, Inject, InjectionToken, Input, NgModule, NgZone, Optional, Self } from '@angular/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operators/auditTime';\nimport { takeUntil } from 'rxjs/operators/takeUntil';\nimport { Subject } from 'rxjs/Subject';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to automatically resize a textarea to fit its content.\n */\nclass MatTextareaAutosize {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _platform\n   * @param {?=} _ngZone\n   */\n  constructor(_elementRef, _platform, _ngZone) {\n    this._elementRef = _elementRef;\n    this._platform = _platform;\n    this._ngZone = _ngZone;\n    this._destroyed = new Subject();\n  }\n  /**\n   * Minimum amount of rows in the textarea.\n   * @param {?} value\n   * @return {?}\n   */\n  set minRows(value) {\n    this._minRows = value;\n    this._setMinHeight();\n  }\n  /**\n   * @return {?}\n   */\n  get minRows() {\n    return this._minRows;\n  }\n  /**\n   * Maximum amount of rows in the textarea.\n   * @return {?}\n   */\n  get maxRows() {\n    return this._maxRows;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set maxRows(value) {\n    this._maxRows = value;\n    this._setMaxHeight();\n  }\n  /**\n   * Sets the minimum height of the textarea as determined by minRows.\n   * @return {?}\n   */\n  _setMinHeight() {\n    const /** @type {?} */minHeight = this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n    if (minHeight) {\n      this._setTextareaStyle('minHeight', minHeight);\n    }\n  }\n  /**\n   * Sets the maximum height of the textarea as determined by maxRows.\n   * @return {?}\n   */\n  _setMaxHeight() {\n    const /** @type {?} */maxHeight = this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n    if (maxHeight) {\n      this._setTextareaStyle('maxHeight', maxHeight);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this.resizeToFitContent();\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() => {\n          fromEvent(window, 'resize').pipe(auditTime(16), takeUntil(this._destroyed)).subscribe(() => this.resizeToFitContent(true));\n        });\n      }\n    }\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /**\n   * Sets a style property on the textarea element.\n   * @param {?} property\n   * @param {?} value\n   * @return {?}\n   */\n  _setTextareaStyle(property, value) {\n    const /** @type {?} */textarea = /** @type {?} */this._elementRef.nativeElement;\n    textarea.style[property] = value;\n  }\n  /**\n   * Cache the height of a single-row textarea if it has not already been cached.\n   *\n   * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n   * maxRows. For the initial version, we will assume that the height of a single line in the\n   * textarea does not ever change.\n   * @return {?}\n   */\n  _cacheTextareaLineHeight() {\n    if (this._cachedLineHeight) {\n      return;\n    }\n    let /** @type {?} */textarea = /** @type {?} */this._elementRef.nativeElement;\n    // Use a clone element because we have to override some styles.\n    let /** @type {?} */textareaClone = /** @type {?} */textarea.cloneNode(false);\n    textareaClone.rows = 1;\n    // Use `position: absolute` so that this doesn't cause a browser layout and use\n    // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n    // would affect the height.\n    textareaClone.style.position = 'absolute';\n    textareaClone.style.visibility = 'hidden';\n    textareaClone.style.border = 'none';\n    textareaClone.style.padding = '0';\n    textareaClone.style.height = '';\n    textareaClone.style.minHeight = '';\n    textareaClone.style.maxHeight = '';\n    // In Firefox it happens that textarea elements are always bigger than the specified amount\n    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n    // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n    // to hidden. This ensures that there is no invalid calculation of the line height.\n    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n    textareaClone.style.overflow = 'hidden'; /** @type {?} */\n    textarea.parentNode.appendChild(textareaClone);\n    this._cachedLineHeight = textareaClone.clientHeight; /** @type {?} */\n    textarea.parentNode.removeChild(textareaClone);\n    // Min and max heights have to be re-calculated if the cached line height changes\n    this._setMinHeight();\n    this._setMaxHeight();\n  }\n  /**\n   * @return {?}\n   */\n  ngDoCheck() {\n    if (this._platform.isBrowser) {\n      this.resizeToFitContent();\n    }\n  }\n  /**\n   * Resize the textarea to fit its content.\n   * @param {?=} force Whether to force a height recalculation. By default the height will be\n   *    recalculated only if the value changed since the last call.\n   * @return {?}\n   */\n  resizeToFitContent(force = false) {\n    this._cacheTextareaLineHeight();\n    // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n    // in checking the height of the textarea.\n    if (!this._cachedLineHeight) {\n      return;\n    }\n    const /** @type {?} */textarea = /** @type {?} */this._elementRef.nativeElement;\n    const /** @type {?} */value = textarea.value;\n    // Only resize of the value changed since these calculations can be expensive.\n    if (value === this._previousValue && !force) {\n      return;\n    }\n    const /** @type {?} */placeholderText = textarea.placeholder;\n    // Reset the textarea height to auto in order to shrink back to its default size.\n    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n    // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n    // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n    // need to be removed temporarily.\n    textarea.style.height = 'auto';\n    textarea.style.overflow = 'hidden';\n    textarea.placeholder = '';\n    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n    textarea.style.height = `${textarea.scrollHeight}px`;\n    textarea.style.overflow = '';\n    textarea.placeholder = placeholderText;\n    this._previousValue = value;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nconst MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\nlet nextUniqueId = 0;\n/**\n * \\@docs-private\n */\nclass MatInputBase {\n  /**\n   * @param {?} _defaultErrorStateMatcher\n   * @param {?} _parentForm\n   * @param {?} _parentFormGroup\n   * @param {?} ngControl\n   */\n  constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n    this._parentForm = _parentForm;\n    this._parentFormGroup = _parentFormGroup;\n    this.ngControl = ngControl;\n  }\n}\nconst _MatInputMixinBase = mixinErrorState(MatInputBase);\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n */\nclass MatInput extends _MatInputMixinBase {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _platform\n   * @param {?} ngControl\n   * @param {?} _parentForm\n   * @param {?} _parentFormGroup\n   * @param {?} _defaultErrorStateMatcher\n   * @param {?} inputValueAccessor\n   */\n  constructor(_elementRef, _platform, /** @docs-private */\n  ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n    this._elementRef = _elementRef;\n    this._platform = _platform;\n    this.ngControl = ngControl;\n    this._uid = `mat-input-${nextUniqueId++}`;\n    /**\n     * Whether the component is being rendered on the server.\n     */\n    this._isServer = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n    this.focused = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n    this.stateChanges = new Subject();\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n    this.controlType = 'mat-input';\n    this._disabled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     */\n    this.placeholder = '';\n    this._required = false;\n    this._type = 'text';\n    this._readonly = false;\n    this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(t => getSupportedInputTypes().has(t));\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;\n    this._previousNativeValue = this.value;\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      _elementRef.nativeElement.addEventListener('keyup', event => {\n        let /** @type {?} */el = /** @type {?} */event.target;\n        if (!el.value && !el.selectionStart && !el.selectionEnd) {\n          // Note: Just setting `0, 0` doesn't fix the issue. Setting `1, 1` fixes it for the first\n          // time that you type text and then hold delete. Toggling to `1, 1` and then back to\n          // `0, 0` seems to completely fix it.\n          el.setSelectionRange(1, 1);\n          el.setSelectionRange(0, 0);\n        }\n      });\n    }\n    this._isServer = !this._platform.isBrowser;\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  get disabled() {\n    if (this.ngControl && this.ngControl.disabled !== null) {\n      return this.ngControl.disabled;\n    }\n    return this._disabled;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  get id() {\n    return this._id;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set id(value) {\n    this._id = value || this._uid;\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  get required() {\n    return this._required;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set required(value) {\n    this._required = coerceBooleanProperty(value);\n  }\n  /**\n   * Input type of the element.\n   * @return {?}\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set type(value) {\n    this._type = value || 'text';\n    this._validateType();\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n      this._elementRef.nativeElement.type = this._type;\n    }\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  get value() {\n    return this._inputValueAccessor.value;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set value(value) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Whether the element is readonly.\n   * @return {?}\n   */\n  get readonly() {\n    return this._readonly;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set readonly(value) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.stateChanges.complete();\n  }\n  /**\n   * @return {?}\n   */\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n  }\n  /**\n   * Focuses the input.\n   * @return {?}\n   */\n  focus() {\n    this._elementRef.nativeElement.focus();\n  }\n  /**\n   * Callback for the cases where the focused state of the input changes.\n   * @param {?} isFocused\n   * @return {?}\n   */\n  _focusChanged(isFocused) {\n    if (isFocused !== this.focused && !this.readonly) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n  /**\n   * Does some manual dirty checking on the native input `value` property.\n   * @return {?}\n   */\n  _dirtyCheckNativeValue() {\n    const /** @type {?} */newValue = this.value;\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n  /**\n   * Make sure the input is a supported type.\n   * @return {?}\n   */\n  _validateType() {\n    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n  /**\n   * Checks whether the input type is one of the types that are never empty.\n   * @return {?}\n   */\n  _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n  /**\n   * Checks whether the input is invalid based on the native validation.\n   * @return {?}\n   */\n  _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let /** @type {?} */validity = /** @type {?} */this._elementRef.nativeElement.validity;\n    return validity && validity.badInput;\n  }\n  /**\n   * Determines if the component host is a textarea. If not recognizable it returns false.\n   * @return {?}\n   */\n  _isTextarea() {\n    let /** @type {?} */nativeElement = this._elementRef.nativeElement;\n    // In Universal, we don't have access to `nodeName`, but the same can be achieved with `name`.\n    // Note that this shouldn't be necessary once Angular switches to an API that resembles the\n    // DOM closer.\n    let /** @type {?} */nodeName = this._platform.isBrowser ? nativeElement.nodeName : nativeElement.name;\n    return nodeName ? nodeName.toLowerCase() === 'textarea' : false;\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  get empty() {\n    return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput();\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  get shouldLabelFloat() {\n    return this.focused || !this.empty;\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @param {?} ids\n   * @return {?}\n   */\n  setDescribedByIds(ids) {\n    this._ariaDescribedby = ids.join(' ');\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * \\@docs-private\n   * @return {?}\n   */\n  onContainerClick() {\n    this.focus();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nclass MatInputModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatInputModule, MatTextareaAutosize, MatInputBase, _MatInputMixinBase, MatInput, getMatInputUnsupportedTypeError, MAT_INPUT_VALUE_ACCESSOR };\n//# sourceMappingURL=input.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}