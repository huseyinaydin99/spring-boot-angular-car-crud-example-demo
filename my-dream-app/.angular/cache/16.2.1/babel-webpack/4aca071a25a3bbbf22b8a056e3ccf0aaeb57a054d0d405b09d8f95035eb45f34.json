{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { take } from 'rxjs/operators/take';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nclass NoopScrollStrategy {\n  /**\n   * Does nothing, as this scroll strategy is a no-op.\n   * @return {?}\n   */\n  enable() {}\n  /**\n   * Does nothing, as this scroll strategy is a no-op.\n   * @return {?}\n   */\n  disable() {}\n  /**\n   * Does nothing, as this scroll strategy is a no-op.\n   * @return {?}\n   */\n  attach() {}\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nclass OverlayConfig {\n  /**\n   * @param {?=} config\n   */\n  constructor(config) {\n    /**\n     * Strategy to be used when handling scroll events while the overlay is open.\n     */\n    this.scrollStrategy = new NoopScrollStrategy();\n    /**\n     * Custom class to add to the overlay pane.\n     */\n    this.panelClass = '';\n    /**\n     * Whether the overlay has a backdrop.\n     */\n    this.hasBackdrop = false;\n    /**\n     * Custom class to add to the backdrop\n     */\n    this.backdropClass = 'cdk-overlay-dark-backdrop';\n    /**\n     * The direction of the text in the overlay panel.\n     */\n    this.direction = 'ltr';\n    if (config) {\n      Object.keys(config).filter(key => typeof config[key] !== 'undefined').forEach(key => this[key] = config[key]);\n    }\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nclass ConnectionPositionPair {\n  /**\n   * @param {?} origin\n   * @param {?} overlay\n   * @param {?=} offsetX\n   * @param {?=} offsetY\n   */\n  constructor(origin, overlay, offsetX, offsetY) {\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    this.originX = origin.originX;\n    this.originY = origin.originY;\n    this.overlayX = overlay.overlayX;\n    this.overlayY = overlay.overlayY;\n  }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nclass ScrollingVisibility {}\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nclass ConnectedOverlayPositionChange {\n  /**\n   * @param {?} connectionPair\n   * @param {?} scrollableViewProperties\n   */\n  constructor(connectionPair, /** @docs-private */\n  scrollableViewProperties) {\n    this.connectionPair = connectionPair;\n    this.scrollableViewProperties = scrollableViewProperties;\n  }\n}\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n  return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n  /**\n   * @param {?} _scrollDispatcher\n   * @param {?} _ngZone\n   * @param {?} _viewportRuler\n   * @param {?=} _config\n   */\n  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._ngZone = _ngZone;\n    this._viewportRuler = _viewportRuler;\n    this._config = _config;\n    this._scrollSubscription = null;\n    /**\n     * Detaches the overlay ref and disables the scroll strategy.\n     */\n    this._detach = () => {\n      this.disable();\n      if (this._overlayRef.hasAttached()) {\n        this._ngZone.run(() => this._overlayRef.detach());\n      }\n    };\n  }\n  /**\n   * Attaches this scroll strategy to an overlay.\n   * @param {?} overlayRef\n   * @return {?}\n   */\n  attach(overlayRef) {\n    if (this._overlayRef) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n    this._overlayRef = overlayRef;\n  }\n  /**\n   * Enables the closing of the attached overlay on scroll.\n   * @return {?}\n   */\n  enable() {\n    if (this._scrollSubscription) {\n      return;\n    }\n    const /** @type {?} */stream = this._scrollDispatcher.scrolled(0);\n    if (this._config && this._config.threshold && this._config.threshold > 1) {\n      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n      this._scrollSubscription = stream.subscribe(() => {\n        const /** @type {?} */scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n        if (Math.abs(scrollPosition - this._initialScrollPosition) > /** @type {?} */ /** @type {?} */this._config.threshold) {\n          this._detach();\n        } else {\n          this._overlayRef.updatePosition();\n        }\n      });\n    } else {\n      this._scrollSubscription = stream.subscribe(this._detach);\n    }\n  }\n  /**\n   * Disables the closing the attached overlay on scroll.\n   * @return {?}\n   */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n  /**\n   * @param {?} _viewportRuler\n   * @param {?} document\n   */\n  constructor(_viewportRuler, document) {\n    this._viewportRuler = _viewportRuler;\n    this._previousHTMLStyles = {\n      top: '',\n      left: ''\n    };\n    this._isEnabled = false;\n    this._document = document;\n  }\n  /**\n   * Attaches this scroll strategy to an overlay.\n   * @return {?}\n   */\n  attach() {}\n  /**\n   * Blocks page-level scroll while the attached overlay is open.\n   * @return {?}\n   */\n  enable() {\n    if (this._canBeEnabled()) {\n      const /** @type {?} */root = this._document.documentElement;\n      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n      // Cache the previous inline styles in case the user had set them.\n      this._previousHTMLStyles.left = root.style.left || '';\n      this._previousHTMLStyles.top = root.style.top || '';\n      // Note: we're using the `html` node, instead of the `body`, because the `body` may\n      // have the user agent margin, whereas the `html` is guaranteed not to have one.\n      root.style.left = `${-this._previousScrollPosition.left}px`;\n      root.style.top = `${-this._previousScrollPosition.top}px`;\n      root.classList.add('cdk-global-scrollblock');\n      this._isEnabled = true;\n    }\n  }\n  /**\n   * Unblocks page-level scroll while the attached overlay is open.\n   * @return {?}\n   */\n  disable() {\n    if (this._isEnabled) {\n      const /** @type {?} */html = this._document.documentElement;\n      const /** @type {?} */body = this._document.body;\n      const /** @type {?} */previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n      const /** @type {?} */previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n      this._isEnabled = false;\n      html.style.left = this._previousHTMLStyles.left;\n      html.style.top = this._previousHTMLStyles.top;\n      html.classList.remove('cdk-global-scrollblock');\n      // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n      // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n      html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n      html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n      body.style['scrollBehavior'] = previousBodyScrollBehavior;\n    }\n  }\n  /**\n   * @return {?}\n   */\n  _canBeEnabled() {\n    // Since the scroll strategies can't be singletons, we have to use a global CSS class\n    // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n    // scrolling multiple times.\n    const /** @type {?} */html = this._document.documentElement;\n    if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n      return false;\n    }\n    const /** @type {?} */body = this._document.body;\n    const /** @type {?} */viewport = this._viewportRuler.getViewportSize();\n    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n  return scrollContainers.some(containerBounds => {\n    const /** @type {?} */outsideAbove = element.bottom < containerBounds.top;\n    const /** @type {?} */outsideBelow = element.top > containerBounds.bottom;\n    const /** @type {?} */outsideLeft = element.right < containerBounds.left;\n    const /** @type {?} */outsideRight = element.left > containerBounds.right;\n    return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n  });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n  return scrollContainers.some(scrollContainerRect => {\n    const /** @type {?} */clippedAbove = element.top < scrollContainerRect.top;\n    const /** @type {?} */clippedBelow = element.bottom > scrollContainerRect.bottom;\n    const /** @type {?} */clippedLeft = element.left < scrollContainerRect.left;\n    const /** @type {?} */clippedRight = element.right > scrollContainerRect.right;\n    return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n  /**\n   * @param {?} _scrollDispatcher\n   * @param {?} _viewportRuler\n   * @param {?} _ngZone\n   * @param {?=} _config\n   */\n  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewportRuler = _viewportRuler;\n    this._ngZone = _ngZone;\n    this._config = _config;\n    this._scrollSubscription = null;\n  }\n  /**\n   * Attaches this scroll strategy to an overlay.\n   * @param {?} overlayRef\n   * @return {?}\n   */\n  attach(overlayRef) {\n    if (this._overlayRef) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n    this._overlayRef = overlayRef;\n  }\n  /**\n   * Enables repositioning of the attached overlay on scroll.\n   * @return {?}\n   */\n  enable() {\n    if (!this._scrollSubscription) {\n      const /** @type {?} */throttle = this._config ? this._config.scrollThrottle : 0;\n      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n        this._overlayRef.updatePosition();\n        // TODO(crisbeto): make `close` on by default once all components can handle it.\n        if (this._config && this._config.autoClose) {\n          const /** @type {?} */overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n          const {\n            width,\n            height\n          } = this._viewportRuler.getViewportSize();\n          // TODO(crisbeto): include all ancestor scroll containers here once\n          // we have a way of exposing the trigger element to the scroll strategy.\n          const /** @type {?} */parentRects = [{\n            width,\n            height,\n            bottom: height,\n            right: width,\n            top: 0,\n            left: 0\n          }];\n          if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n            this.disable();\n            this._ngZone.run(() => this._overlayRef.detach());\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Disables repositioning of the attached overlay on scroll.\n   * @return {?}\n   */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n  /**\n   * @param {?} _scrollDispatcher\n   * @param {?} _viewportRuler\n   * @param {?} _ngZone\n   * @param {?} document\n   */\n  constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewportRuler = _viewportRuler;\n    this._ngZone = _ngZone;\n    /**\n     * Do nothing on scroll.\n     */\n    this.noop = () => new NoopScrollStrategy();\n    /**\n     * Close the overlay as soon as the user scrolls.\n     * @param config Configuration to be used inside the scroll strategy.\n     */\n    this.close = config => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n    /**\n     * Block scrolling.\n     */\n    this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);\n    /**\n     * Update the overlay's position on scroll.\n     * @param config Configuration to be used inside the scroll strategy.\n     * Allows debouncing the reposition calls.\n     */\n    this.reposition = config => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n    this._document = document;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n  /**\n   * @param {?} _portalOutlet\n   * @param {?} _pane\n   * @param {?} _config\n   * @param {?} _ngZone\n   * @param {?} _keyboardDispatcher\n   * @param {?} _document\n   */\n  constructor(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher, _document) {\n    this._portalOutlet = _portalOutlet;\n    this._pane = _pane;\n    this._config = _config;\n    this._ngZone = _ngZone;\n    this._keyboardDispatcher = _keyboardDispatcher;\n    this._document = _document;\n    this._backdropElement = null;\n    this._backdropClick = new Subject();\n    this._attachments = new Subject();\n    this._detachments = new Subject();\n    /**\n     * Stream of keydown events dispatched to this overlay.\n     */\n    this._keydownEvents = new Subject();\n    if (_config.scrollStrategy) {\n      _config.scrollStrategy.attach(this);\n    }\n  }\n  /**\n   * The overlay's HTML element\n   * @return {?}\n   */\n  get overlayElement() {\n    return this._pane;\n  }\n  /**\n   * The overlay's backdrop HTML element.\n   * @return {?}\n   */\n  get backdropElement() {\n    return this._backdropElement;\n  }\n  /**\n   * Attaches content, given via a Portal, to the overlay.\n   * If the overlay is configured to have a backdrop, it will be created.\n   *\n   * @param {?} portal Portal instance to which to attach the overlay.\n   * @return {?} The portal attachment result.\n   */\n  attach(portal) {\n    let /** @type {?} */attachResult = this._portalOutlet.attach(portal);\n    if (this._config.positionStrategy) {\n      this._config.positionStrategy.attach(this);\n    }\n    // Update the pane element with the given configuration.\n    this._updateStackingOrder();\n    this._updateElementSize();\n    this._updateElementDirection();\n    if (this._config.scrollStrategy) {\n      this._config.scrollStrategy.enable();\n    }\n    // Update the position once the zone is stable so that the overlay will be fully rendered\n    // before attempting to position it, as the position may depend on the size of the rendered\n    // content.\n    this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n      // The overlay could've been detached before the zone has stabilized.\n      if (this.hasAttached()) {\n        this.updatePosition();\n      }\n    });\n    // Enable pointer events for the overlay pane element.\n    this._togglePointerEvents(true);\n    if (this._config.hasBackdrop) {\n      this._attachBackdrop();\n    }\n    if (this._config.panelClass) {\n      // We can't do a spread here, because IE doesn't support setting multiple classes.\n      if (Array.isArray(this._config.panelClass)) {\n        this._config.panelClass.forEach(cls => this._pane.classList.add(cls));\n      } else {\n        this._pane.classList.add(this._config.panelClass);\n      }\n    }\n    // Only emit the `attachments` event once all other setup is done.\n    this._attachments.next();\n    // Track this overlay by the keyboard dispatcher\n    this._keyboardDispatcher.add(this);\n    return attachResult;\n  }\n  /**\n   * Detaches an overlay from a portal.\n   * @return {?} The portal detachment result.\n   */\n  detach() {\n    if (!this.hasAttached()) {\n      return;\n    }\n    this.detachBackdrop();\n    // When the overlay is detached, the pane element should disable pointer events.\n    // This is necessary because otherwise the pane element will cover the page and disable\n    // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n    this._togglePointerEvents(false);\n    if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n      this._config.positionStrategy.detach();\n    }\n    if (this._config.scrollStrategy) {\n      this._config.scrollStrategy.disable();\n    }\n    const /** @type {?} */detachmentResult = this._portalOutlet.detach();\n    // Only emit after everything is detached.\n    this._detachments.next();\n    // Remove this overlay from keyboard dispatcher tracking\n    this._keyboardDispatcher.remove(this);\n    return detachmentResult;\n  }\n  /**\n   * Cleans up the overlay from the DOM.\n   * @return {?}\n   */\n  dispose() {\n    const /** @type {?} */isAttached = this.hasAttached();\n    if (this._config.positionStrategy) {\n      this._config.positionStrategy.dispose();\n    }\n    if (this._config.scrollStrategy) {\n      this._config.scrollStrategy.disable();\n    }\n    this.detachBackdrop();\n    this._keyboardDispatcher.remove(this);\n    this._portalOutlet.dispose();\n    this._attachments.complete();\n    this._backdropClick.complete();\n    this._keydownEvents.complete();\n    if (isAttached) {\n      this._detachments.next();\n    }\n    this._detachments.complete();\n  }\n  /**\n   * Whether the overlay has attached content.\n   * @return {?}\n   */\n  hasAttached() {\n    return this._portalOutlet.hasAttached();\n  }\n  /**\n   * Gets an observable that emits when the backdrop has been clicked.\n   * @return {?}\n   */\n  backdropClick() {\n    return this._backdropClick.asObservable();\n  }\n  /**\n   * Gets an observable that emits when the overlay has been attached.\n   * @return {?}\n   */\n  attachments() {\n    return this._attachments.asObservable();\n  }\n  /**\n   * Gets an observable that emits when the overlay has been detached.\n   * @return {?}\n   */\n  detachments() {\n    return this._detachments.asObservable();\n  }\n  /**\n   * Gets an observable of keydown events targeted to this overlay.\n   * @return {?}\n   */\n  keydownEvents() {\n    return this._keydownEvents.asObservable();\n  }\n  /**\n   * Gets the the current overlay configuration, which is immutable.\n   * @return {?}\n   */\n  getConfig() {\n    return this._config;\n  }\n  /**\n   * Updates the position of the overlay based on the position strategy.\n   * @return {?}\n   */\n  updatePosition() {\n    if (this._config.positionStrategy) {\n      this._config.positionStrategy.apply();\n    }\n  }\n  /**\n   * Update the size properties of the overlay.\n   * @param {?} sizeConfig\n   * @return {?}\n   */\n  updateSize(sizeConfig) {\n    this._config = Object.assign({}, this._config, sizeConfig);\n    this._updateElementSize();\n  }\n  /**\n   * Sets the LTR/RTL direction for the overlay.\n   * @param {?} dir\n   * @return {?}\n   */\n  setDirection(dir) {\n    this._config = Object.assign({}, this._config, {\n      direction: dir\n    });\n    this._updateElementDirection();\n  }\n  /**\n   * Updates the text direction of the overlay panel.\n   * @return {?}\n   */\n  _updateElementDirection() {\n    this._pane.setAttribute('dir', /** @type {?} */this._config.direction);\n  }\n  /**\n   * Updates the size of the overlay element based on the overlay config.\n   * @return {?}\n   */\n  _updateElementSize() {\n    if (this._config.width || this._config.width === 0) {\n      this._pane.style.width = formatCssUnit(this._config.width);\n    }\n    if (this._config.height || this._config.height === 0) {\n      this._pane.style.height = formatCssUnit(this._config.height);\n    }\n    if (this._config.minWidth || this._config.minWidth === 0) {\n      this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n    }\n    if (this._config.minHeight || this._config.minHeight === 0) {\n      this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n    }\n    if (this._config.maxWidth || this._config.maxWidth === 0) {\n      this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n    }\n    if (this._config.maxHeight || this._config.maxHeight === 0) {\n      this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n    }\n  }\n  /**\n   * Toggles the pointer events for the overlay pane element.\n   * @param {?} enablePointer\n   * @return {?}\n   */\n  _togglePointerEvents(enablePointer) {\n    this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n  }\n  /**\n   * Attaches a backdrop for this overlay.\n   * @return {?}\n   */\n  _attachBackdrop() {\n    const /** @type {?} */showingClass = 'cdk-overlay-backdrop-showing';\n    this._backdropElement = this._document.createElement('div');\n    this._backdropElement.classList.add('cdk-overlay-backdrop');\n    if (this._config.backdropClass) {\n      this._backdropElement.classList.add(this._config.backdropClass);\n    } /** @type {?} */\n    // Insert the backdrop before the pane in the DOM order,\n    // in order to handle stacked overlays properly.\n    this._pane.parentElement.insertBefore(this._backdropElement, this._pane);\n    // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n    // action desired when such a click occurs (usually closing the overlay).\n    this._backdropElement.addEventListener('click', event => this._backdropClick.next(event));\n    // Add class to fade-in the backdrop after one frame.\n    if (typeof requestAnimationFrame !== 'undefined') {\n      this._ngZone.runOutsideAngular(() => {\n        requestAnimationFrame(() => {\n          if (this._backdropElement) {\n            this._backdropElement.classList.add(showingClass);\n          }\n        });\n      });\n    } else {\n      this._backdropElement.classList.add(showingClass);\n    }\n  }\n  /**\n   * Updates the stacking order of the element, moving it to the top if necessary.\n   * This is required in cases where one overlay was detached, while another one,\n   * that should be behind it, was destroyed. The next time both of them are opened,\n   * the stacking will be wrong, because the detached element's pane will still be\n   * in its original DOM position.\n   * @return {?}\n   */\n  _updateStackingOrder() {\n    if (this._pane.nextSibling) {\n      /** @type {?} */this._pane.parentNode.appendChild(this._pane);\n    }\n  }\n  /**\n   * Detaches the backdrop (if any) associated with the overlay.\n   * @return {?}\n   */\n  detachBackdrop() {\n    let /** @type {?} */backdropToDetach = this._backdropElement;\n    if (backdropToDetach) {\n      let /** @type {?} */finishDetach = () => {\n        // It may not be attached to anything in certain cases (e.g. unit tests).\n        if (backdropToDetach && backdropToDetach.parentNode) {\n          backdropToDetach.parentNode.removeChild(backdropToDetach);\n        }\n        // It is possible that a new portal has been attached to this overlay since we started\n        // removing the backdrop. If that is the case, only clear the backdrop reference if it\n        // is still the same instance that we started to remove.\n        if (this._backdropElement == backdropToDetach) {\n          this._backdropElement = null;\n        }\n      };\n      backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n      if (this._config.backdropClass) {\n        backdropToDetach.classList.remove(this._config.backdropClass);\n      }\n      backdropToDetach.addEventListener('transitionend', finishDetach);\n      // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n      // In this case we make it unclickable and we try to remove it after a delay.\n      backdropToDetach.style.pointerEvents = 'none';\n      // Run this outside the Angular zone because there's nothing that Angular cares about.\n      // If it were to run inside the Angular zone, every test that used Overlay would have to be\n      // either async or fakeAsync.\n      this._ngZone.runOutsideAngular(() => {\n        setTimeout(finishDetach, 500);\n      });\n    }\n  }\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n  return typeof value === 'string' ? /** @type {?} */value : `${value}px`;\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass ConnectedPositionStrategy {\n  /**\n   * @param {?} originPos\n   * @param {?} overlayPos\n   * @param {?} _connectedTo\n   * @param {?} _viewportRuler\n   * @param {?} _document\n   */\n  constructor(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n    this._connectedTo = _connectedTo;\n    this._viewportRuler = _viewportRuler;\n    this._document = _document;\n    /**\n     * Layout direction of the position strategy.\n     */\n    this._dir = 'ltr';\n    /**\n     * The offset in pixels for the overlay connection point on the x-axis\n     */\n    this._offsetX = 0;\n    /**\n     * The offset in pixels for the overlay connection point on the y-axis\n     */\n    this._offsetY = 0;\n    /**\n     * The Scrollable containers used to check scrollable view properties on position change.\n     */\n    this.scrollables = [];\n    /**\n     * Subscription to viewport resize events.\n     */\n    this._resizeSubscription = Subscription.EMPTY;\n    /**\n     * Ordered list of preferred positions, from most to least desirable.\n     */\n    this._preferredPositions = [];\n    /**\n     * Whether the position strategy is applied currently.\n     */\n    this._applied = false;\n    /**\n     * Whether the overlay position is locked.\n     */\n    this._positionLocked = false;\n    this._onPositionChange = new Subject();\n    this._origin = this._connectedTo.nativeElement;\n    this.withFallbackPosition(originPos, overlayPos);\n  }\n  /**\n   * Whether the we're dealing with an RTL context\n   * @return {?}\n   */\n  get _isRtl() {\n    return this._dir === 'rtl';\n  }\n  /**\n   * Emits an event when the connection point changes.\n   * @return {?}\n   */\n  get onPositionChange() {\n    return this._onPositionChange.asObservable();\n  }\n  /**\n   * Ordered list of preferred positions, from most to least desirable.\n   * @return {?}\n   */\n  get positions() {\n    return this._preferredPositions;\n  }\n  /**\n   * Attach this position strategy to an overlay.\n   * @param {?} overlayRef\n   * @return {?}\n   */\n  attach(overlayRef) {\n    this._pane = overlayRef.overlayElement;\n    this._resizeSubscription.unsubscribe();\n    this._resizeSubscription = this._viewportRuler.change().subscribe(() => this.apply());\n  }\n  /**\n   * Disposes all resources used by the position strategy.\n   * @return {?}\n   */\n  dispose() {\n    this._applied = false;\n    this._resizeSubscription.unsubscribe();\n    this._onPositionChange.complete();\n  }\n  /**\n   * \\@docs-private\n   * @return {?}\n   */\n  detach() {\n    this._applied = false;\n    this._resizeSubscription.unsubscribe();\n  }\n  /**\n   * Updates the position of the overlay element, using whichever preferred position relative\n   * to the origin fits on-screen.\n   * \\@docs-private\n   * @return {?}\n   */\n  apply() {\n    // If the position has been applied already (e.g. when the overlay was opened) and the\n    // consumer opted into locking in the position, re-use the  old position, in order to\n    // prevent the overlay from jumping around.\n    if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n      this.recalculateLastPosition();\n      return;\n    }\n    this._applied = true;\n    // We need the bounding rects for the origin and the overlay to determine how to position\n    // the overlay relative to the origin.\n    const /** @type {?} */element = this._pane;\n    const /** @type {?} */originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */overlayRect = element.getBoundingClientRect();\n    // We use the viewport size to determine whether a position would go off-screen.\n    const /** @type {?} */viewportSize = this._viewportRuler.getViewportSize();\n    // Fallback point if none of the fallbacks fit into the viewport.\n    let /** @type {?} */fallbackPoint;\n    let /** @type {?} */fallbackPosition;\n    // We want to place the overlay in the first of the preferred positions such that the\n    // overlay fits on-screen.\n    for (let /** @type {?} */pos of this._preferredPositions) {\n      // Get the (x, y) point of connection on the origin, and then use that to get the\n      // (top, left) coordinate for the overlay at `pos`.\n      let /** @type {?} */originPoint = this._getOriginConnectionPoint(originRect, pos);\n      let /** @type {?} */overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\n      if (overlayPoint.fitsInViewport) {\n        this._setElementPosition(element, overlayRect, overlayPoint, pos);\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastConnectedPosition = pos;\n        return;\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n        fallbackPoint = overlayPoint;\n        fallbackPosition = pos;\n      }\n    }\n    // If none of the preferred positions were in the viewport, take the one\n    // with the largest visible area.\n    this._setElementPosition(element, overlayRect, /** @type {?} */fallbackPoint, /** @type {?} */fallbackPosition);\n  }\n  /**\n   * Re-positions the overlay element with the trigger in its last calculated position,\n   * even if a position higher in the \"preferred positions\" list would now fit. This\n   * allows one to re-align the panel without changing the orientation of the panel.\n   * @return {?}\n   */\n  recalculateLastPosition() {\n    // If the overlay has never been positioned before, do nothing.\n    if (!this._lastConnectedPosition) {\n      return;\n    }\n    const /** @type {?} */originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */overlayRect = this._pane.getBoundingClientRect();\n    const /** @type {?} */viewportSize = this._viewportRuler.getViewportSize();\n    const /** @type {?} */lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n    let /** @type {?} */originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n    let /** @type {?} */overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n    this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n  }\n  /**\n   * Sets the list of Scrollable containers that host the origin element so that\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n   * Scrollable must be an ancestor element of the strategy's origin element.\n   * @param {?} scrollables\n   * @return {?}\n   */\n  withScrollableContainers(scrollables) {\n    this.scrollables = scrollables;\n  }\n  /**\n   * Adds a new preferred fallback position.\n   * @param {?} originPos\n   * @param {?} overlayPos\n   * @param {?=} offsetX\n   * @param {?=} offsetY\n   * @return {?}\n   */\n  withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {\n    const /** @type {?} */position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n    this._preferredPositions.push(position);\n    return this;\n  }\n  /**\n   * Sets the layout direction so the overlay's position can be adjusted to match.\n   * @param {?} dir New layout direction.\n   * @return {?}\n   */\n  withDirection(dir) {\n    this._dir = dir;\n    return this;\n  }\n  /**\n   * Sets an offset for the overlay's connection point on the x-axis\n   * @param {?} offset New offset in the X axis.\n   * @return {?}\n   */\n  withOffsetX(offset) {\n    this._offsetX = offset;\n    return this;\n  }\n  /**\n   * Sets an offset for the overlay's connection point on the y-axis\n   * @param {?} offset New offset in the Y axis.\n   * @return {?}\n   */\n  withOffsetY(offset) {\n    this._offsetY = offset;\n    return this;\n  }\n  /**\n   * Sets whether the overlay's position should be locked in after it is positioned\n   * initially. When an overlay is locked in, it won't attempt to reposition itself\n   * when the position is re-applied (e.g. when the user scrolls away).\n   * @param {?} isLocked Whether the overlay should locked in.\n   * @return {?}\n   */\n  withLockedPosition(isLocked) {\n    this._positionLocked = isLocked;\n    return this;\n  }\n  /**\n   * Overwrites the current set of positions with an array of new ones.\n   * @param {?} positions Position pairs to be set on the strategy.\n   * @return {?}\n   */\n  withPositions(positions) {\n    this._preferredPositions = positions.slice();\n    return this;\n  }\n  /**\n   * Sets the origin element, relative to which to position the overlay.\n   * @param {?} origin Reference to the new origin element.\n   * @return {?}\n   */\n  setOrigin(origin) {\n    this._origin = origin.nativeElement;\n    return this;\n  }\n  /**\n   * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n   * @param {?} rect\n   * @return {?}\n   */\n  _getStartX(rect) {\n    return this._isRtl ? rect.right : rect.left;\n  }\n  /**\n   * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n   * @param {?} rect\n   * @return {?}\n   */\n  _getEndX(rect) {\n    return this._isRtl ? rect.left : rect.right;\n  }\n  /**\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n   * @param {?} originRect\n   * @param {?} pos\n   * @return {?}\n   */\n  _getOriginConnectionPoint(originRect, pos) {\n    const /** @type {?} */originStartX = this._getStartX(originRect);\n    const /** @type {?} */originEndX = this._getEndX(originRect);\n    let /** @type {?} */x;\n    if (pos.originX == 'center') {\n      x = originStartX + originRect.width / 2;\n    } else {\n      x = pos.originX == 'start' ? originStartX : originEndX;\n    }\n    let /** @type {?} */y;\n    if (pos.originY == 'center') {\n      y = originRect.top + originRect.height / 2;\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n    return {\n      x,\n      y\n    };\n  }\n  /**\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n   * origin point to which the overlay should be connected, as well as how much of the element\n   * would be inside the viewport at that position.\n   * @param {?} originPoint\n   * @param {?} overlayRect\n   * @param {?} viewportSize\n   * @param {?} pos\n   * @return {?}\n   */\n  _getOverlayPoint(originPoint, overlayRect, viewportSize, pos) {\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n    // relative to the origin point.\n    let /** @type {?} */overlayStartX;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n    }\n    let /** @type {?} */overlayStartY;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n    // The (x, y) offsets of the overlay based on the current position.\n    let /** @type {?} */offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n    let /** @type {?} */offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n    // The (x, y) coordinates of the overlay.\n    let /** @type {?} */x = originPoint.x + overlayStartX + offsetX;\n    let /** @type {?} */y = originPoint.y + overlayStartY + offsetY;\n    // How much the overlay would overflow at this position, on each side.\n    let /** @type {?} */leftOverflow = 0 - x;\n    let /** @type {?} */rightOverflow = x + overlayRect.width - viewportSize.width;\n    let /** @type {?} */topOverflow = 0 - y;\n    let /** @type {?} */bottomOverflow = y + overlayRect.height - viewportSize.height;\n    // Visible parts of the element on each axis.\n    let /** @type {?} */visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n    let /** @type {?} */visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n    // The area of the element that's within the viewport.\n    let /** @type {?} */visibleArea = visibleWidth * visibleHeight;\n    let /** @type {?} */fitsInViewport = overlayRect.width * overlayRect.height === visibleArea;\n    return {\n      x,\n      y,\n      fitsInViewport,\n      visibleArea\n    };\n  }\n  /**\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\n   * or completely outside the view of any of the strategy's scrollables.\n   * @param {?} overlay\n   * @return {?}\n   */\n  _getScrollVisibility(overlay) {\n    const /** @type {?} */originBounds = this._origin.getBoundingClientRect();\n    const /** @type {?} */overlayBounds = overlay.getBoundingClientRect();\n    const /** @type {?} */scrollContainerBounds = this.scrollables.map(s => s.getElementRef().nativeElement.getBoundingClientRect());\n    return {\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)\n    };\n  }\n  /**\n   * Physically positions the overlay element to the given coordinate.\n   * @param {?} element\n   * @param {?} overlayRect\n   * @param {?} overlayPoint\n   * @param {?} pos\n   * @return {?}\n   */\n  _setElementPosition(element, overlayRect, overlayPoint, pos) {\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n    // or below the origin and the direction in which the element will expand.\n    let /** @type {?} */verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n    // When using `bottom`, we adjust the y position such that it is the distance\n    // from the bottom of the viewport rather than the top.\n    let /** @type {?} */y = verticalStyleProperty === 'top' ? overlayPoint.y : this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n    // or \"after\" the origin, which determines the direction in which the element will expand.\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n    // page is in RTL or LTR.\n    let /** @type {?} */horizontalStyleProperty;\n    if (this._dir === 'rtl') {\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n    } else {\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n    }\n    // When we're setting `right`, we adjust the x position such that it is the distance\n    // from the right edge of the viewport rather than the left edge.\n    let /** @type {?} */x = horizontalStyleProperty === 'left' ? overlayPoint.x : this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n    // Reset any existing styles. This is necessary in case the preferred position has\n    // changed since the last `apply`.\n    ['top', 'bottom', 'left', 'right'].forEach(p => element.style[p] = null);\n    element.style[verticalStyleProperty] = `${y}px`;\n    element.style[horizontalStyleProperty] = `${x}px`;\n    // Notify that the position has been changed along with its change properties.\n    const /** @type {?} */scrollableViewProperties = this._getScrollVisibility(element);\n    const /** @type {?} */positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n    this._onPositionChange.next(positionChange);\n  }\n  /**\n   * Subtracts the amount that an element is overflowing on an axis from it's length.\n   * @param {?} length\n   * @param {...?} overflows\n   * @return {?}\n   */\n  _subtractOverflows(length, ...overflows) {\n    return overflows.reduce((currentValue, currentOverflow) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n  /**\n   * @param {?} _document\n   */\n  constructor(_document) {\n    this._document = _document;\n    this._cssPosition = 'static';\n    this._topOffset = '';\n    this._bottomOffset = '';\n    this._leftOffset = '';\n    this._rightOffset = '';\n    this._alignItems = '';\n    this._justifyContent = '';\n    this._width = '';\n    this._height = '';\n    /**\n     * A lazily-created wrapper for the overlay element that is used as a flex container.\n     */\n    this._wrapper = null;\n  }\n  /**\n   * @param {?} overlayRef\n   * @return {?}\n   */\n  attach(overlayRef) {\n    const /** @type {?} */config = overlayRef.getConfig();\n    this._overlayRef = overlayRef;\n    if (this._width && !config.width) {\n      overlayRef.updateSize({\n        width: this._width\n      });\n    }\n    if (this._height && !config.height) {\n      overlayRef.updateSize({\n        height: this._height\n      });\n    }\n  }\n  /**\n   * Sets the top position of the overlay. Clears any previously set vertical position.\n   * @param {?=} value New top offset.\n   * @return {?}\n   */\n  top(value = '') {\n    this._bottomOffset = '';\n    this._topOffset = value;\n    this._alignItems = 'flex-start';\n    return this;\n  }\n  /**\n   * Sets the left position of the overlay. Clears any previously set horizontal position.\n   * @param {?=} value New left offset.\n   * @return {?}\n   */\n  left(value = '') {\n    this._rightOffset = '';\n    this._leftOffset = value;\n    this._justifyContent = 'flex-start';\n    return this;\n  }\n  /**\n   * Sets the bottom position of the overlay. Clears any previously set vertical position.\n   * @param {?=} value New bottom offset.\n   * @return {?}\n   */\n  bottom(value = '') {\n    this._topOffset = '';\n    this._bottomOffset = value;\n    this._alignItems = 'flex-end';\n    return this;\n  }\n  /**\n   * Sets the right position of the overlay. Clears any previously set horizontal position.\n   * @param {?=} value New right offset.\n   * @return {?}\n   */\n  right(value = '') {\n    this._leftOffset = '';\n    this._rightOffset = value;\n    this._justifyContent = 'flex-end';\n    return this;\n  }\n  /**\n   * Sets the overlay width and clears any previously set width.\n   * @deprecated Pass the `width` through the `OverlayConfig`.\n   * \\@deletion-target 7.0.0\n   * @param {?=} value New width for the overlay\n   * @return {?}\n   */\n  width(value = '') {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({\n        width: value\n      });\n    } else {\n      this._width = value;\n    }\n    return this;\n  }\n  /**\n   * Sets the overlay height and clears any previously set height.\n   * @deprecated Pass the `height` through the `OverlayConfig`.\n   * \\@deletion-target 7.0.0\n   * @param {?=} value New height for the overlay\n   * @return {?}\n   */\n  height(value = '') {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({\n        height: value\n      });\n    } else {\n      this._height = value;\n    }\n    return this;\n  }\n  /**\n   * Centers the overlay horizontally with an optional offset.\n   * Clears any previously set horizontal position.\n   *\n   * @param {?=} offset Overlay offset from the horizontal center.\n   * @return {?}\n   */\n  centerHorizontally(offset = '') {\n    this.left(offset);\n    this._justifyContent = 'center';\n    return this;\n  }\n  /**\n   * Centers the overlay vertically with an optional offset.\n   * Clears any previously set vertical position.\n   *\n   * @param {?=} offset Overlay offset from the vertical center.\n   * @return {?}\n   */\n  centerVertically(offset = '') {\n    this.top(offset);\n    this._alignItems = 'center';\n    return this;\n  }\n  /**\n   * Apply the position to the element.\n   * \\@docs-private\n   *\n   * @return {?} Resolved when the styles have been applied.\n   */\n  apply() {\n    // Since the overlay ref applies the strategy asynchronously, it could\n    // have been disposed before it ends up being applied. If that is the\n    // case, we shouldn't do anything.\n    if (!this._overlayRef.hasAttached()) {\n      return;\n    }\n    const /** @type {?} */element = this._overlayRef.overlayElement;\n    if (!this._wrapper && element.parentNode) {\n      this._wrapper = this._document.createElement('div'); /** @type {?} */\n      this._wrapper.classList.add('cdk-global-overlay-wrapper');\n      element.parentNode.insertBefore( /** @type {?} */this._wrapper, element); /** @type {?} */\n      this._wrapper.appendChild(element);\n    }\n    const /** @type {?} */styles = element.style;\n    const /** @type {?} */parentStyles = /** @type {?} */element.parentNode.style;\n    const /** @type {?} */config = this._overlayRef.getConfig();\n    styles.position = this._cssPosition;\n    styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n    styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n    styles.marginBottom = this._bottomOffset;\n    styles.marginRight = this._rightOffset;\n    parentStyles.justifyContent = config.width === '100%' ? 'flex-start' : this._justifyContent;\n    parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n  }\n  /**\n   * Removes the wrapper element from the DOM.\n   * @return {?}\n   */\n  dispose() {\n    if (this._wrapper && this._wrapper.parentNode) {\n      this._wrapper.parentNode.removeChild(this._wrapper);\n      this._wrapper = null;\n    }\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nclass OverlayPositionBuilder {\n  /**\n   * @param {?} _viewportRuler\n   * @param {?} _document\n   */\n  constructor(_viewportRuler, _document) {\n    this._viewportRuler = _viewportRuler;\n    this._document = _document;\n  }\n  /**\n   * Creates a global position strategy.\n   * @return {?}\n   */\n  global() {\n    return new GlobalPositionStrategy(this._document);\n  }\n  /**\n   * Creates a relative position strategy.\n   * @param {?} elementRef\n   * @param {?} originPos\n   * @param {?} overlayPos\n   * @return {?}\n   */\n  connectedTo(elementRef, originPos, overlayPos) {\n    return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher {\n  /**\n   * @param {?} _document\n   */\n  constructor(_document) {\n    this._document = _document;\n    /**\n     * Currently attached overlays in the order they were attached.\n     */\n    this._attachedOverlays = [];\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._unsubscribeFromKeydownEvents();\n  }\n  /**\n   * Add a new overlay to the list of attached overlay refs.\n   * @param {?} overlayRef\n   * @return {?}\n   */\n  add(overlayRef) {\n    // Lazily start dispatcher once first overlay is added\n    if (!this._keydownEventSubscription) {\n      this._subscribeToKeydownEvents();\n    }\n    this._attachedOverlays.push(overlayRef);\n  }\n  /**\n   * Remove an overlay from the list of attached overlay refs.\n   * @param {?} overlayRef\n   * @return {?}\n   */\n  remove(overlayRef) {\n    const /** @type {?} */index = this._attachedOverlays.indexOf(overlayRef);\n    if (index > -1) {\n      this._attachedOverlays.splice(index, 1);\n    }\n    // Remove the global listener once there are no more overlays.\n    if (this._attachedOverlays.length === 0) {\n      this._unsubscribeFromKeydownEvents();\n    }\n  }\n  /**\n   * Subscribe to keydown events that land on the body and dispatch those\n   * events to the appropriate overlay.\n   * @return {?}\n   */\n  _subscribeToKeydownEvents() {\n    const /** @type {?} */bodyKeydownEvents = fromEvent(this._document.body, 'keydown', true);\n    this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(() => !!this._attachedOverlays.length)).subscribe(event => {\n      // Dispatch keydown event to the correct overlay.\n      this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n    });\n  }\n  /**\n   * Removes the global keydown subscription.\n   * @return {?}\n   */\n  _unsubscribeFromKeydownEvents() {\n    if (this._keydownEventSubscription) {\n      this._keydownEventSubscription.unsubscribe();\n      this._keydownEventSubscription = null;\n    }\n  }\n  /**\n   * Select the appropriate overlay from a keydown event.\n   * @param {?} event\n   * @return {?}\n   */\n  _selectOverlayFromEvent(event) {\n    // Check if any overlays contain the event\n    const /** @type {?} */targetedOverlay = this._attachedOverlays.find(overlay => {\n      return overlay.overlayElement === event.target || overlay.overlayElement.contains( /** @type {?} */event.target);\n    });\n    // Use the overlay if it exists, otherwise choose the most recently attached one\n    return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n  }\n}\n\n/** @nocollapse */\n\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n  return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nconst OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n  // If there is already an OverlayKeyboardDispatcher available, use that.\n  // Otherwise, provide a new one.\n  provide: OverlayKeyboardDispatcher,\n  deps: [[new Optional(), new SkipSelf(), OverlayKeyboardDispatcher], /** @type {?} */\n  // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n  // of the type expected by Angular\n  DOCUMENT],\n  useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nclass OverlayContainer {\n  /**\n   * @param {?} _document\n   */\n  constructor(_document) {\n    this._document = _document;\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this._containerElement && this._containerElement.parentNode) {\n      this._containerElement.parentNode.removeChild(this._containerElement);\n    }\n  }\n  /**\n   * This method returns the overlay container element. It will lazily\n   * create the element the first time  it is called to facilitate using\n   * the container in non-browser environments.\n   * @return {?} the container element\n   */\n  getContainerElement() {\n    if (!this._containerElement) {\n      this._createContainer();\n    }\n    return this._containerElement;\n  }\n  /**\n   * Create the overlay container element, which is simply a div\n   * with the 'cdk-overlay-container' class on the document body.\n   * @return {?}\n   */\n  _createContainer() {\n    const /** @type {?} */container = this._document.createElement('div');\n    container.classList.add('cdk-overlay-container');\n    this._document.body.appendChild(container);\n    this._containerElement = container;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n  return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nconst OVERLAY_CONTAINER_PROVIDER = {\n  // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n  provide: OverlayContainer,\n  deps: [[new Optional(), new SkipSelf(), OverlayContainer], /** @type {?} */DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n  // We need to use the InjectionToken somewhere to keep TS happy\n  ],\n\n  useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nlet nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n  /**\n   * @param {?} scrollStrategies\n   * @param {?} _overlayContainer\n   * @param {?} _componentFactoryResolver\n   * @param {?} _positionBuilder\n   * @param {?} _keyboardDispatcher\n   * @param {?} _appRef\n   * @param {?} _injector\n   * @param {?} _ngZone\n   * @param {?} _document\n   */\n  constructor(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n    this.scrollStrategies = scrollStrategies;\n    this._overlayContainer = _overlayContainer;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._positionBuilder = _positionBuilder;\n    this._keyboardDispatcher = _keyboardDispatcher;\n    this._appRef = _appRef;\n    this._injector = _injector;\n    this._ngZone = _ngZone;\n    this._document = _document;\n  }\n  /**\n   * Creates an overlay.\n   * @param {?=} config Configuration applied to the overlay.\n   * @return {?} Reference to the created overlay.\n   */\n  create(config) {\n    const /** @type {?} */pane = this._createPaneElement();\n    const /** @type {?} */portalOutlet = this._createPortalOutlet(pane);\n    return new OverlayRef(portalOutlet, pane, new OverlayConfig(config), this._ngZone, this._keyboardDispatcher, this._document);\n  }\n  /**\n   * Gets a position builder that can be used, via fluent API,\n   * to construct and configure a position strategy.\n   * @return {?} An overlay position builder.\n   */\n  position() {\n    return this._positionBuilder;\n  }\n  /**\n   * Creates the DOM element for an overlay and appends it to the overlay container.\n   * @return {?} Newly-created pane element\n   */\n  _createPaneElement() {\n    const /** @type {?} */pane = this._document.createElement('div');\n    pane.id = `cdk-overlay-${nextUniqueId++}`;\n    pane.classList.add('cdk-overlay-pane');\n    this._overlayContainer.getContainerElement().appendChild(pane);\n    return pane;\n  }\n  /**\n   * Create a DomPortalOutlet into which the overlay content can be loaded.\n   * @param {?} pane The DOM element to turn into a portal outlet.\n   * @return {?} A portal outlet for the given DOM element.\n   */\n  _createPortalOutlet(pane) {\n    return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nconst defaultPositionList = [new ConnectionPositionPair({\n  originX: 'start',\n  originY: 'bottom'\n}, {\n  overlayX: 'start',\n  overlayY: 'top'\n}), new ConnectionPositionPair({\n  originX: 'start',\n  originY: 'top'\n}, {\n  overlayX: 'start',\n  overlayY: 'bottom'\n}), new ConnectionPositionPair({\n  originX: 'end',\n  originY: 'top'\n}, {\n  overlayX: 'end',\n  overlayY: 'bottom'\n}), new ConnectionPositionPair({\n  originX: 'end',\n  originY: 'bottom'\n}, {\n  overlayX: 'end',\n  overlayY: 'top'\n})];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/**\n * \\@docs-private\n */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n  /**\n   * @param {?} elementRef\n   */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n  /**\n   * @param {?} _overlay\n   * @param {?} templateRef\n   * @param {?} viewContainerRef\n   * @param {?} _scrollStrategy\n   * @param {?} _dir\n   */\n  constructor(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n    this._overlay = _overlay;\n    this._scrollStrategy = _scrollStrategy;\n    this._dir = _dir;\n    this._hasBackdrop = false;\n    this._lockPosition = false;\n    this._backdropSubscription = Subscription.EMPTY;\n    this._offsetX = 0;\n    this._offsetY = 0;\n    /**\n     * Strategy to be used when handling scroll events while the overlay is open.\n     */\n    this.scrollStrategy = this._scrollStrategy();\n    /**\n     * Whether the overlay is open.\n     */\n    this.open = false;\n    /**\n     * Event emitted when the backdrop is clicked.\n     */\n    this.backdropClick = new EventEmitter();\n    /**\n     * Event emitted when the position has changed.\n     */\n    this.positionChange = new EventEmitter();\n    /**\n     * Event emitted when the overlay has been attached.\n     */\n    this.attach = new EventEmitter();\n    /**\n     * Event emitted when the overlay has been detached.\n     */\n    this.detach = new EventEmitter();\n    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n  }\n  /**\n   * The offset in pixels for the overlay connection point on the x-axis\n   * @return {?}\n   */\n  get offsetX() {\n    return this._offsetX;\n  }\n  /**\n   * @param {?} offsetX\n   * @return {?}\n   */\n  set offsetX(offsetX) {\n    this._offsetX = offsetX;\n    if (this._position) {\n      this._position.withOffsetX(offsetX);\n    }\n  }\n  /**\n   * The offset in pixels for the overlay connection point on the y-axis\n   * @return {?}\n   */\n  get offsetY() {\n    return this._offsetY;\n  }\n  /**\n   * @param {?} offsetY\n   * @return {?}\n   */\n  set offsetY(offsetY) {\n    this._offsetY = offsetY;\n    if (this._position) {\n      this._position.withOffsetY(offsetY);\n    }\n  }\n  /**\n   * Whether or not the overlay should attach a backdrop.\n   * @return {?}\n   */\n  get hasBackdrop() {\n    return this._hasBackdrop;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set hasBackdrop(value) {\n    this._hasBackdrop = coerceBooleanProperty(value);\n  }\n  /**\n   * Whether or not the overlay should be locked when scrolling.\n   * @return {?}\n   */\n  get lockPosition() {\n    return this._lockPosition;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set lockPosition(value) {\n    this._lockPosition = coerceBooleanProperty(value);\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedOrigin() {\n    return this.origin;\n  }\n  /**\n   * @param {?} _origin\n   * @return {?}\n   */\n  set _deprecatedOrigin(_origin) {\n    this.origin = _origin;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedPositions() {\n    return this.positions;\n  }\n  /**\n   * @param {?} _positions\n   * @return {?}\n   */\n  set _deprecatedPositions(_positions) {\n    this.positions = _positions;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedOffsetX() {\n    return this.offsetX;\n  }\n  /**\n   * @param {?} _offsetX\n   * @return {?}\n   */\n  set _deprecatedOffsetX(_offsetX) {\n    this.offsetX = _offsetX;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedOffsetY() {\n    return this.offsetY;\n  }\n  /**\n   * @param {?} _offsetY\n   * @return {?}\n   */\n  set _deprecatedOffsetY(_offsetY) {\n    this.offsetY = _offsetY;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedWidth() {\n    return this.width;\n  }\n  /**\n   * @param {?} _width\n   * @return {?}\n   */\n  set _deprecatedWidth(_width) {\n    this.width = _width;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedHeight() {\n    return this.height;\n  }\n  /**\n   * @param {?} _height\n   * @return {?}\n   */\n  set _deprecatedHeight(_height) {\n    this.height = _height;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedMinWidth() {\n    return this.minWidth;\n  }\n  /**\n   * @param {?} _minWidth\n   * @return {?}\n   */\n  set _deprecatedMinWidth(_minWidth) {\n    this.minWidth = _minWidth;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedMinHeight() {\n    return this.minHeight;\n  }\n  /**\n   * @param {?} _minHeight\n   * @return {?}\n   */\n  set _deprecatedMinHeight(_minHeight) {\n    this.minHeight = _minHeight;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedBackdropClass() {\n    return this.backdropClass;\n  }\n  /**\n   * @param {?} _backdropClass\n   * @return {?}\n   */\n  set _deprecatedBackdropClass(_backdropClass) {\n    this.backdropClass = _backdropClass;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedScrollStrategy() {\n    return this.scrollStrategy;\n  }\n  /**\n   * @param {?} _scrollStrategy\n   * @return {?}\n   */\n  set _deprecatedScrollStrategy(_scrollStrategy) {\n    this.scrollStrategy = _scrollStrategy;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedOpen() {\n    return this.open;\n  }\n  /**\n   * @param {?} _open\n   * @return {?}\n   */\n  set _deprecatedOpen(_open) {\n    this.open = _open;\n  }\n  /**\n   * @deprecated\n   * \\@deletion-target 6.0.0\n   * @return {?}\n   */\n  get _deprecatedHasBackdrop() {\n    return this.hasBackdrop;\n  }\n  /**\n   * @param {?} _hasBackdrop\n   * @return {?}\n   */\n  set _deprecatedHasBackdrop(_hasBackdrop) {\n    this.hasBackdrop = _hasBackdrop;\n  }\n  /**\n   * The associated overlay reference.\n   * @return {?}\n   */\n  get overlayRef() {\n    return this._overlayRef;\n  }\n  /**\n   * The element's layout direction.\n   * @return {?}\n   */\n  get dir() {\n    return this._dir ? this._dir.value : 'ltr';\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this._destroyOverlay();\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    if (this._position) {\n      if (changes['positions'] || changes['_deprecatedPositions']) {\n        this._position.withPositions(this.positions);\n      }\n      if (changes['lockPosition']) {\n        this._position.withLockedPosition(this.lockPosition);\n      }\n      if (changes['origin'] || changes['_deprecatedOrigin']) {\n        this._position.setOrigin(this.origin.elementRef);\n        if (this.open) {\n          this._position.apply();\n        }\n      }\n    }\n    if (changes['open'] || changes['_deprecatedOpen']) {\n      this.open ? this._attachOverlay() : this._detachOverlay();\n    }\n  }\n  /**\n   * Creates an overlay\n   * @return {?}\n   */\n  _createOverlay() {\n    if (!this.positions || !this.positions.length) {\n      this.positions = defaultPositionList;\n    }\n    this._overlayRef = this._overlay.create(this._buildConfig());\n  }\n  /**\n   * Builds the overlay config based on the directive's inputs\n   * @return {?}\n   */\n  _buildConfig() {\n    const /** @type {?} */positionStrategy = this._position = this._createPositionStrategy();\n    const /** @type {?} */overlayConfig = new OverlayConfig({\n      positionStrategy,\n      scrollStrategy: this.scrollStrategy,\n      hasBackdrop: this.hasBackdrop\n    });\n    if (this.width || this.width === 0) {\n      overlayConfig.width = this.width;\n    }\n    if (this.height || this.height === 0) {\n      overlayConfig.height = this.height;\n    }\n    if (this.minWidth || this.minWidth === 0) {\n      overlayConfig.minWidth = this.minWidth;\n    }\n    if (this.minHeight || this.minHeight === 0) {\n      overlayConfig.minHeight = this.minHeight;\n    }\n    if (this.backdropClass) {\n      overlayConfig.backdropClass = this.backdropClass;\n    }\n    return overlayConfig;\n  }\n  /**\n   * Returns the position strategy of the overlay to be set on the overlay config\n   * @return {?}\n   */\n  _createPositionStrategy() {\n    const /** @type {?} */primaryPosition = this.positions[0];\n    const /** @type {?} */originPoint = {\n      originX: primaryPosition.originX,\n      originY: primaryPosition.originY\n    };\n    const /** @type {?} */overlayPoint = {\n      overlayX: primaryPosition.overlayX,\n      overlayY: primaryPosition.overlayY\n    };\n    const /** @type {?} */strategy = this._overlay.position().connectedTo(this.origin.elementRef, originPoint, overlayPoint).withOffsetX(this.offsetX).withOffsetY(this.offsetY).withLockedPosition(this.lockPosition);\n    for (let /** @type {?} */i = 1; i < this.positions.length; i++) {\n      strategy.withFallbackPosition({\n        originX: this.positions[i].originX,\n        originY: this.positions[i].originY\n      }, {\n        overlayX: this.positions[i].overlayX,\n        overlayY: this.positions[i].overlayY\n      });\n    }\n    strategy.onPositionChange.subscribe(pos => this.positionChange.emit(pos));\n    return strategy;\n  }\n  /**\n   * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n   * @return {?}\n   */\n  _attachOverlay() {\n    if (!this._overlayRef) {\n      this._createOverlay(); /** @type {?} */\n      this._overlayRef.keydownEvents().subscribe(event => {\n        if (event.keyCode === ESCAPE) {\n          this._detachOverlay();\n        }\n      });\n    } else {\n      // Update the overlay size, in case the directive's inputs have changed\n      this._overlayRef.updateSize({\n        width: this.width,\n        minWidth: this.minWidth,\n        height: this.height,\n        minHeight: this.minHeight\n      });\n    }\n    this._position.withDirection(this.dir);\n    this._overlayRef.setDirection(this.dir);\n    if (!this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._templatePortal);\n      this.attach.emit();\n    }\n    if (this.hasBackdrop) {\n      this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n        this.backdropClick.emit(event);\n      });\n    }\n  }\n  /**\n   * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n   * @return {?}\n   */\n  _detachOverlay() {\n    if (this._overlayRef) {\n      this._overlayRef.detach();\n      this.detach.emit();\n    }\n    this._backdropSubscription.unsubscribe();\n  }\n  /**\n   * Destroys the overlay created by this directive.\n   * @return {?}\n   */\n  _destroyOverlay() {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n    }\n    this._backdropSubscription.unsubscribe();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nconst OVERLAY_PROVIDERS = [Overlay, OverlayPositionBuilder, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER, VIEWPORT_RULER_PROVIDER, OVERLAY_CONTAINER_PROVIDER, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER];\nclass OverlayModule {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nclass FullscreenOverlayContainer extends OverlayContainer {\n  /**\n   * @return {?}\n   */\n  _createContainer() {\n    super._createContainer();\n    this._adjustParentForFullscreenChange();\n    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n  }\n  /**\n   * @return {?}\n   */\n  _adjustParentForFullscreenChange() {\n    if (!this._containerElement) {\n      return;\n    }\n    let /** @type {?} */fullscreenElement = this.getFullscreenElement();\n    let /** @type {?} */parent = fullscreenElement || document.body;\n    parent.appendChild(this._containerElement);\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  _addFullscreenChangeListener(fn) {\n    if (document.fullscreenEnabled) {\n      document.addEventListener('fullscreenchange', fn);\n    } else if (document.webkitFullscreenEnabled) {\n      document.addEventListener('webkitfullscreenchange', fn);\n    } else if ( /** @type {?} */document.mozFullScreenEnabled) {\n      document.addEventListener('mozfullscreenchange', fn);\n    } else if ( /** @type {?} */document.msFullscreenEnabled) {\n      document.addEventListener('MSFullscreenChange', fn);\n    }\n  }\n  /**\n   * When the page is put into fullscreen mode, a specific element is specified.\n   * Only that element and its children are visible when in fullscreen mode.\n   * @return {?}\n   */\n  getFullscreenElement() {\n    return document.fullscreenElement || document.webkitFullscreenElement || /** @type {?} */document.mozFullScreenElement || /** @type {?} */document.msFullscreenElement || null;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as g, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as f, OVERLAY_CONTAINER_PROVIDER as b, OVERLAY_CONTAINER_PROVIDER_FACTORY as a, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as c, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as e, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as d };\n//# sourceMappingURL=overlay.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}